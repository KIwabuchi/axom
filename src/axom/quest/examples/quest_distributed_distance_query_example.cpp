// Copyright (c) 2017-2022, Lawrence Livermore National Security, LLC and
// other Axom Project Developers. See the top-level COPYRIGHT file for details.
//
// SPDX-License-Identifier: (BSD-3-Clause)

/*!
 * \file quest_distributed_distance_query_example.cpp
 * \brief Driver for a distributed distance query
 */

// Axom includes
#include "axom/config.hpp"
#include "axom/core.hpp"
#include "axom/slic.hpp"
#include "axom/primal.hpp"
#include "axom/sidre.hpp"
#include "axom/quest.hpp"
#include "axom/slam.hpp"
#include "axom/core/Types.hpp"
#include "axom/core/utilities/WhereMacro.hpp"

#include "conduit_blueprint.hpp"
#include "conduit_blueprint_mpi.hpp"
#include "conduit_relay_io_blueprint.hpp"
#include "conduit_relay_mpi_io_blueprint.hpp"

#include "axom/quest/DistributedClosestPoint.hpp"

#include "axom/fmt.hpp"
#include "axom/CLI11.hpp"

#ifndef AXOM_USE_MPI
  #error This example requires Axom to be configured with MPI
#endif
#include "mpi.h"

// C/C++ includes
#include <string>
#include <limits>
#include <map>
#include <vector>
#include <cmath>

namespace quest = axom::quest;
namespace slic = axom::slic;
namespace sidre = axom::sidre;
namespace slam = axom::slam;
namespace spin = axom::spin;
namespace primal = axom::primal;
namespace mint = axom::mint;
namespace numerics = axom::numerics;

using RuntimePolicy = axom::quest::DistributedClosestPoint::RuntimePolicy;

// converts the input string into an 80 character string
// padded on both sides with '=' symbols
std::string banner(const std::string& str)
{
  return axom::fmt::format("{:=^80}", str);
}

/// Struct to parse and store the input parameters
struct Input
{
public:
  std::string meshFile;
  std::string distanceFile {"cp_coords"};
  std::string objectFile {"object_mesh"};

  double circleRadius {1.0};
  std::vector<double> circleCenter {0.0, 0.0};
  // TODO: Ensure that circleCenter size matches dimensionality.
  int circlePoints {100};
  RuntimePolicy policy {RuntimePolicy::seq};

  double distThreshold {std::numeric_limits<double>::max()};

  bool checkResults {false};

  bool randomSpacing {true};

  std::vector<unsigned int> objDomainCountRange {1, 1};

private:
  bool m_verboseOutput {false};
  double m_emptyRankProbability {0.};

  // clang-format off
  const std::map<std::string, RuntimePolicy> s_validPolicies
  {
      {"seq", RuntimePolicy::seq}
#if defined(AXOM_USE_RAJA) && defined(AXOM_USE_UMPIRE)
  #ifdef AXOM_USE_OPENMP
    , {"omp", RuntimePolicy::omp}
  #endif
  #ifdef AXOM_USE_CUDA
    , {"cuda", RuntimePolicy::cuda}
  #endif
  #ifdef AXOM_USE_HIP
    , {"hip", RuntimePolicy::hip}
  #endif
#endif
  };
  // clang-format on

public:
  bool isVerbose() const { return m_verboseOutput; }
  double percentEmptyRanks() const { return m_emptyRankProbability; }

  std::string getDCMeshName() const
  {
    using axom::utilities::string::removeSuffix;

    // Remove the parent directories and file suffix
    std::string name = axom::Path(meshFile).baseName();
    name = removeSuffix(name, ".root");

    return name;
  }

  std::string getMdMeshName() const
  {
    using axom::utilities::string::removeSuffix;

    // Remove the parent directories and file suffix
    std::string name = axom::Path(meshFile).baseName();
    name = removeSuffix(name, ".root");

    return name;
  }

  void parse(int argc, char** argv, axom::CLI::App& app)
  {
    app.add_option("-m,--mesh-file", meshFile)
      ->description(
        "Path to multidomain computational mesh (generated by conduit)")
      ->check(axom::CLI::ExistingFile);

    app.add_option("-s,--distance-file", distanceFile)
      ->description("Name of output mesh file containing closest distance.")
      ->capture_default_str();

    app.add_option("-o,--object-file", objectFile)
      ->description("Name of output file containing object mesh.")
      ->capture_default_str();

    app.add_flag("-v,--verbose,!--no-verbose", m_verboseOutput)
      ->description("Enable/disable verbose output")
      ->capture_default_str();

    app.add_option("--empty-rank-probability", m_emptyRankProbability)
      ->description(
        "Probability that a rank's data is empty "
        "(tests code's ability to handle empty ranks)")
      ->check(axom::CLI::Range(0., 1.))
      ->capture_default_str();

    app.add_option("-r,--radius", circleRadius)
      ->description("Radius for circle")
      ->capture_default_str();

    auto* circle_options =
      app.add_option_group("circle",
                           "Options for setting up the circle of points");
    circle_options->add_option("--center", circleCenter)
      ->description("Center for object (x,y[,z])")
      ->expected(2, 3);

    circle_options->add_option("--obj-domain-count-range", objDomainCountRange)
      ->description("Range of object domain counts/rank (min, max)")
      ->expected(2);

    app.add_flag("--random-spacing,!--no-random-spacing", randomSpacing)
      ->description("Enable/disable random spacing of circle points")
      ->capture_default_str();

    app.add_option("-d,--dist-threshold", distThreshold)
      ->check(axom::CLI::NonNegativeNumber)
      ->description("Distance threshold to search")
      ->capture_default_str();

    app.add_option("-n,--num-samples", circlePoints)
      ->description("Number of points for circle")
      ->capture_default_str();

    app.add_option("-p, --policy", policy)
      ->description("Set runtime policy for point query method")
      ->capture_default_str()
      ->transform(axom::CLI::CheckedTransformer(s_validPolicies));

    app.add_flag("-c,--check-results,!--no-check-results", checkResults)
      ->description(
        "Enable/disable checking results against analytical solution")
      ->capture_default_str();

    app.get_formatter()->column_width(60);

    // could throw an exception
    app.parse(argc, argv);

    slic::setLoggingMsgLevel(m_verboseOutput ? slic::message::Debug
                                             : slic::message::Info);
  }
};

/**
 *  \brief Simple wrapper to a blueprint particle mesh
 *
 *  Given a sidre Group, creates the stubs for a mesh blueptint particle mesh
 */
struct BlueprintParticleMesh
{
public:
  using Point2D = primal::Point<double, 2>;
  using Point3D = primal::Point<double, 3>;
  using PointArray2D = axom::Array<Point2D>;
  using PointArray3D = axom::Array<Point3D>;

  explicit BlueprintParticleMesh(sidre::Group* group = nullptr,
                                 const std::string& coordset = "coords",
                                 const std::string& topology = "mesh")
    : m_coordsetName(coordset)
    , m_topologyName(topology)
    , m_group(group)
    , m_domainGroups()
  {
    MPI_Comm_rank(MPI_COMM_WORLD, &m_rank);
    MPI_Comm_size(MPI_COMM_WORLD, &m_nranks);
  }

  /// Gets the root group for this mesh blueprint
  sidre::Group* root_group() const { return m_group; }

  /// Gets number of domains in the multidomain particle mesh
  axom::IndexType domain_count() const { return m_group->getNumGroups(); }

  /// Gets a domain group.
  sidre::Group* domain_group(axom::IndexType groupIdx) const
  {
    SLIC_ASSERT(size_t(groupIdx) < m_domainGroups.size());
    return m_domainGroups[groupIdx];
  }
  /// Gets the parent group for the blueprint coordinate set
  sidre::Group* coords_group(axom::IndexType groupIdx) const
  {
    return m_coordsGroups[groupIdx];
  }
  /// Gets the parent group for the blueprint mesh topology
  sidre::Group* topo_group(axom::IndexType groupIdx) const
  {
    return m_topoGroups[groupIdx];
  }
  /// Gets the parent group for the blueprint fields
  sidre::Group* fields_group(axom::IndexType groupIdx) const
  {
    return m_fieldsGroups[groupIdx];
  }

  const std::string& get_topology_name() const { return m_topologyName; }
  const std::string& getCoordsetName() const { return m_coordsetName; }

  /// Gets the MPI rank for this mesh
  int getRank() const { return m_rank; }
  /// Gets the number of ranks in the problem
  int getNumRanks() const { return m_nranks; }

  /// Returns true if points have been added to the particle mesh
  bool hasPoints() const
  {
    // return m_coordsGroup != nullptr && m_coordsGroup->hasView("values/x");
    for(auto* cg : m_coordsGroups)
    {
      if(cg != nullptr && cg->hasView("values/x")) return true;
    }
    return false;
  }

  /// Returns the number of points in a particle mesh domain
  int numPoints(axom::IndexType dIdx) const
  {
    int rval = 0;
    auto* cg = m_coordsGroups[dIdx];
    //BTNG: The following if-check is probably not a use-case
    if(cg != nullptr && cg->hasView("values/x"))
    {
      rval = cg->getView("values/x")->getNumElements();
    }
    return rval;
  }
  /// Returns the number of points in the particle mesh
  int numPoints() const
  {
    int rval = 0;
    const axom::IndexType domCount = domain_count();
    for(axom::IndexType dIdx = 0; dIdx < domCount; ++dIdx)
    {
      rval += numPoints(dIdx);
    }
    return rval;
  }

  int dimension() const { return m_dimension; }

  /*!
    @brief Read a blueprint mesh.
  */
  void read_blueprint_mesh(const std::string& meshFilename)
  {
    SLIC_ASSERT(!meshFilename.empty());

    m_domainGroups.clear();
    m_coordsGroups.clear();
    m_topoGroups.clear();
    m_fieldsGroups.clear();

    conduit::Node mdMesh;
    conduit::relay::mpi::io::blueprint::load_mesh(meshFilename,
                                                  mdMesh,
                                                  MPI_COMM_WORLD);
    assert(conduit::blueprint::mesh::is_multi_domain(mdMesh));
    conduit::index_t domCount =
      conduit::blueprint::mesh::number_of_domains(mdMesh);

    if(domCount > 0)
    {
      const conduit::Node coordsetNode =
        mdMesh[0].fetch_existing("coordsets").fetch_existing(m_coordsetName);
      m_dimension = conduit::blueprint::mesh::coordset::dims(coordsetNode);
    }
    MPI_Allreduce(MPI_IN_PLACE, &m_dimension, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
    SLIC_ASSERT(m_dimension > 0);

    if(domCount > 0)
    {
      // Put mdMesh into sidre Group.
      bool goodImport = m_group->importConduitTree(mdMesh, false);
      SLIC_ASSERT(goodImport);
      SLIC_ASSERT(m_group->getNumGroups() == domCount);
    }

    bool valid = isValid();
    SLIC_ASSERT(valid);

    reset_group_pointers();
  }

  void reset_group_pointers()
  {
    axom::IndexType domCount = m_group->getNumGroups();
    m_domainGroups.resize(domCount, nullptr);
    m_coordsGroups.resize(domCount, nullptr);
    m_topoGroups.resize(domCount, nullptr);
    m_fieldsGroups.resize(domCount, nullptr);
    for(conduit::index_t di = 0; di < domCount; ++di)
    {
      m_domainGroups[di] = m_group->getGroup(di);
      m_coordsGroups[di] =
        m_domainGroups[di]->getGroup("coordsets")->getGroup(m_coordsetName);
      m_topoGroups[di] =
        m_domainGroups[di]->getGroup("topologies")->getGroup(m_topologyName);
      m_fieldsGroups[di] = m_domainGroups[di]->getGroup("fields");
    }
  }

  /*!  @brief Set the coordinate data from an array of primal Points

    The points are assigned to a new domain (in the multidomain context).

    This method is for manually creating the mesh.  Don't use it if
    the mesh is read in.
  */
  template <int NDIMS>
  void setPoints(const axom::Array<primal::Point<double, NDIMS>>& pts)
  {
    axom::IndexType domainIdx = createBlueprintStubs();
    SLIC_ASSERT(m_domainGroups[domainIdx] != nullptr);

    const int SZ = pts.size();

    if(m_dimension == -1)
    {
      m_dimension = NDIMS;
    }
    else
    {
      SLIC_ASSERT(NDIMS == m_dimension);
    }

    // lamda to create a strided view into the buffer
    // uses workaround for empty meshes since apply() requires size > 0
    auto createAndApplyView = [=](sidre::Group* grp,
                                  const std::string& path,
                                  sidre::Buffer* buf,
                                  int dim,
                                  int sz) {
      if(sz > 0)
      {
        grp->createView(path)->attachBuffer(buf)->apply(sz, dim, NDIMS);
      }
      else
      {
        grp->createViewAndAllocate(path, sidre::DOUBLE_ID, 0);
      }
    };

    // create views into a shared buffer for the coordinates, with stride NDIMS
    {
      auto* buf = m_domainGroups[domainIdx]
                    ->getDataStore()
                    ->createBuffer(sidre::DOUBLE_ID, NDIMS * SZ)
                    ->allocate();

      createAndApplyView(m_coordsGroups[domainIdx], "values/x", buf, 0, SZ);
      if(NDIMS > 1)
      {
        createAndApplyView(m_coordsGroups[domainIdx], "values/y", buf, 1, SZ);
      }
      if(NDIMS > 2)
      {
        createAndApplyView(m_coordsGroups[domainIdx], "values/z", buf, 2, SZ);
      }

      // copy coordinate data into the buffer
      const std::size_t nbytes = sizeof(double) * SZ * NDIMS;
      axom::copy(buf->getVoidPtr(), pts.data(), nbytes);
    }

    // set the default connectivity
    // Maybe be required by an old version of visit.  May not be needed by newer versions of visit.
    sidre::Array<int> arr(
      m_topoGroups[domainIdx]->createView("elements/connectivity"),
      SZ,
      SZ);
    for(int i = 0; i < SZ; ++i)
    {
      arr[i] = i;
    }
  }

  template <int NDIMS>
  axom::Array<primal::Point<double, NDIMS>> getPoints(int domainIdx)
  {
    // This code is untested and currently unused.
    auto* cGroup = m_coordsGroups[domainIdx];
    auto* xView = cGroup->getView("values/x");
    auto* yView = cGroup->getView("values/y");
    auto* zView = NDIMS >= 3 ? cGroup->getView("values/z") : nullptr;
    const auto ptCount = xView->getNumElements();
    assert(xView->getStride() == 1);
    assert(yView->getStride() == 1);
    assert(zView == nullptr || zView->getStride() == 1);
    double* xs = xView->getArray();
    double* ys = yView->getArray();
    double* zs = zView ? (double*)(zView->getArray()) : nullptr;

    using PointType = primal::Point<double, NDIMS>;
    axom::Array<PointType> pts;
    pts.resize(ptCount);
    for(int i = 0; i < ptCount; ++i)
    {
      pts[i][0] = xs[i];
    }
    for(int i = 0; i < ptCount; ++i)
    {
      pts[i][1] = ys[i];
    }
    if(NDIMS == 3)
    {
      for(int i = 0; i < ptCount; ++i)
      {
        pts[i][0] = zs[i];
      }
    }
    return pts;
  }

  template <typename T>
  void registerNodalScalarField(const std::string& fieldName)
  {
    for(axom::IndexType dIdx = 0; dIdx < domain_count(); ++dIdx)
    {
      auto* fld = m_fieldsGroups[dIdx]->createGroup(fieldName);
      fld->createViewString("association", "vertex");
      fld->createViewString("topology", m_topoGroups[dIdx]->getName());
      fld->createViewAndAllocate("values",
                                 sidre::detail::SidreTT<T>::id,
                                 numPoints(dIdx));
    }
  }

  template <typename T>
  void registerNodalVectorField(const std::string& fieldName)
  {
    const int DIM = dimension();
    for(axom::IndexType dIdx = 0; dIdx < domain_count(); ++dIdx)
    {
      const int SZ = numPoints(dIdx);

      auto* fld = m_fieldsGroups[dIdx]->createGroup(fieldName);
      fld->createViewString("association", "vertex");
      fld->createViewString("topology", m_topoGroups[dIdx]->getName());

      // create views into a shared buffer for the coordinates, with stride DIM
      auto* buf = m_domainGroups[dIdx]
                    ->getDataStore()
                    ->createBuffer(sidre::detail::SidreTT<T>::id, DIM * SZ)
                    ->allocate();
      switch(DIM)
      {
      case 3:
        fld->createView("values/x")->attachBuffer(buf)->apply(SZ, 0, DIM);
        fld->createView("values/y")->attachBuffer(buf)->apply(SZ, 1, DIM);
        fld->createView("values/z")->attachBuffer(buf)->apply(SZ, 2, DIM);
        break;
      case 2:
        fld->createView("values/x")->attachBuffer(buf)->apply(SZ, 0, DIM);
        fld->createView("values/y")->attachBuffer(buf)->apply(SZ, 1, DIM);
        break;
      default:
        fld->createView("values/x")->attachBuffer(buf)->apply(SZ, 0, DIM);
        break;
      }
    }
  }

  bool hasField(const std::string& fieldName, int domainIdx = 0) const
  {
    return m_fieldsGroups[domainIdx]->hasGroup(fieldName);
  }

  template <typename T>
  axom::ArrayView<T> getNodalScalarField(const std::string& fieldName,
                                         int domainIdx)
  {
    SLIC_ASSERT_MSG(
      domainIdx >= 0 && size_t(domainIdx) < m_domainGroups.size(),
      axom::fmt::format("Rank {} has no domain {}, only {} domains",
                        m_rank,
                        domainIdx,
                        m_domainGroups.size()));

    T* data = hasField(fieldName)
      ? static_cast<T*>(m_fieldsGroups[domainIdx]
                          ->getView(axom::fmt::format("{}/values", fieldName))
                          ->getVoidPtr())
      : nullptr;

    return axom::ArrayView<T>(data, numPoints(domainIdx));
  }

  template <typename T>
  axom::ArrayView<T> getNodalVectorField(const std::string& fieldName,
                                         int domainIdx)
  {
    SLIC_ASSERT_MSG(
      domainIdx >= 0 && size_t(domainIdx) < m_domainGroups.size(),
      axom::fmt::format("Rank {} has only {} domains, no domain index {}",
                        m_rank,
                        m_domainGroups.size(),
                        domainIdx));

    // Note: the implementation currently assumes that the field data is
    // interleaved, so it is safe to get a pointer to the beginning of the
    // x-coordinate's data. This will be relaxed in the future, and we will
    // need to modify this implementation accordingly.
    T* data = hasField(fieldName)
      ? static_cast<T*>(m_fieldsGroups[domainIdx]
                          ->getView(axom::fmt::format("{}/values/x", fieldName))
                          ->getVoidPtr())
      : nullptr;

    return axom::ArrayView<T>(data, numPoints(domainIdx));
  }

  /// Checks whether the blueprint is valid and prints diagnostics
  bool isValid() const
  {
    {
      conduit::Node meshNode;
      m_group->createNativeLayout(meshNode);
      conduit::Node info;
      if(!conduit::blueprint::mpi::verify("mesh", meshNode, info, MPI_COMM_WORLD))
      {
        SLIC_INFO("Invalid blueprint for particle mesh: \n" << info.to_yaml());
        slic::flushStreams();
        return false;
      }
      // info.print();
    }
    return true;
  }

  /// Outputs the particle mesh to disk
  void saveMesh(const std::string& filename)
  {
    conduit::Node meshNode;
    m_group->createNativeLayout(meshNode);
    conduit::relay::mpi::io::blueprint::save_mesh(meshNode,
                                                  filename,
                                                  "hdf5",
                                                  MPI_COMM_WORLD);
  }

  void print_mesh_info() const
  {
    // Copy to conduit::Node.  It's output is easier to read, especially in parallel.
    conduit::Node meshNode;
    m_group->createNativeLayout(meshNode);
    meshNode.print();
  }

private:
  /// Creates blueprint stubs for this mesh
  // for the "coordset", "topologies", "fields" and "state"
  // Return the domain index created.
  axom::IndexType createBlueprintStubs()
  {
    SLIC_ASSERT(m_group != nullptr);

    auto* domainGroup = m_group->createUnnamedGroup();

    auto* coordsGroup =
      domainGroup->createGroup("coordsets")->createGroup(m_coordsetName);
    coordsGroup->createViewString("type", "explicit");
    coordsGroup->createGroup("values");

    auto* topoGroup =
      domainGroup->createGroup("topologies")->createGroup(m_topologyName);
    topoGroup->createViewString("coordset", m_coordsetName);
    topoGroup->createViewString("type", "unstructured");
    topoGroup->createViewString("elements/shape", "point");

    auto* fieldsGroup = domainGroup->createGroup("fields");

    domainGroup->createViewScalar<axom::int64>("state/domain_id", m_rank);

    m_domainGroups.push_back(domainGroup);
    m_coordsGroups.push_back(coordsGroup);
    m_topoGroups.push_back(topoGroup);
    m_fieldsGroups.push_back(fieldsGroup);

    return axom::IndexType(m_domainGroups.size() - 1);
  }

private:
  const std::string m_coordsetName;
  const std::string m_topologyName;
  /// Parent group for the entire mesh
  sidre::Group* m_group;
  /// Group for each domain in multidomain mesh
  std::vector<sidre::Group*> m_domainGroups;

  std::vector<sidre::Group*> m_coordsGroups;
  std::vector<sidre::Group*> m_topoGroups;
  std::vector<sidre::Group*> m_fieldsGroups;

  int m_rank;
  int m_nranks;
  int m_dimension {-1};
};  // BlueprintParticleMesh

/**
 * Helper class to generate a mesh blueprint-conforming particle mesh for the input object.
 * The mesh is represented using a Sidre hierarchy
 */
class ObjectMeshWrapper
{
public:
  using Circle = primal::Sphere<double, 2>;

  ObjectMeshWrapper(sidre::Group* group) : m_objectMesh(group)
  {
    SLIC_ASSERT(group != nullptr);
  }

  BlueprintParticleMesh& getParticleMesh() { return m_objectMesh; }

  /// Get a pointer to the root group for this mesh
  sidre::Group* getBlueprintGroup() const { return m_objectMesh.root_group(); }

  std::string getCoordsetName() const { return m_objectMesh.getCoordsetName(); }

  void setVerbosity(bool verbose) { m_verbose = verbose; }

  /**
   * Generates a collection of \a numPoints points along a circle.
   * Point spacing can be random (default) or uniform.
   */
  void generateCircleMesh(const Circle& circle,
                          int totalNumPoints,
                          int localDomainCount,
                          bool randomSpacing = true)
  {
    using axom::utilities::random_real;

    constexpr int DIM = 2;
    using PointType = primal::Point<double, DIM>;
    using PointArray = axom::Array<PointType>;

    int rank = m_objectMesh.getRank();
    int nranks = m_objectMesh.getNumRanks();

    // perform scan on ranks to compute totalNumPoints, thetaStart and thetaEnd
    axom::Array<int> sums(nranks, nranks);
    {
      axom::Array<int> indivDomainCounts(nranks, nranks);
      indivDomainCounts.fill(-1);
      MPI_Allgather(&localDomainCount,
                    1,
                    MPI_INT,
                    indivDomainCounts.data(),
                    1,
                    MPI_INT,
                    MPI_COMM_WORLD);

      SLIC_DEBUG_IF(m_verbose,
                    axom::fmt::format("After all gather: [{}]",
                                      axom::fmt::join(indivDomainCounts, ",")));

      sums[0] = indivDomainCounts[0];
      for(int i = 1; i < nranks; ++i)
      {
        sums[i] = sums[i - 1] + indivDomainCounts[i];
      }
      // If no rank has any domains, force last one to 1 domain.
      if(sums[nranks - 1] == 0)
      {
        sums[nranks - 1] = 1;
        if(rank == nranks - 1)
        {
          localDomainCount = 1;
        }
      }
    }

    SLIC_DEBUG_IF(
      m_verbose,
      axom::fmt::format("After scan: [{}]", axom::fmt::join(sums, ",")));

    int globalDomainCount = sums[nranks - 1];
    totalNumPoints = std::max(totalNumPoints, globalDomainCount);
    int ptsPerDomain = totalNumPoints / globalDomainCount;
    int domainsWithExtraPt = totalNumPoints % globalDomainCount;

    int myDomainBegin = rank == 0 ? 0 : sums[rank - 1];
    int myDomainEnd = sums[rank];
    assert(myDomainEnd - myDomainBegin == localDomainCount);

    double radius = circle.getRadius();
    const auto& center = circle.getCenter();
    const double avgAng = 2. * M_PI / totalNumPoints;

    for(int di = myDomainBegin; di < myDomainEnd; ++di)
    {
      int pBegin = di * ptsPerDomain + std::min(di, domainsWithExtraPt);
      int pEnd = (di + 1) * ptsPerDomain + std::min((di + 1), domainsWithExtraPt);
      int domainPointCount = pEnd - pBegin;
      PointArray pts(0, domainPointCount);

      for(int pi = pBegin; pi < pEnd; ++pi)
      {
        const double ang = randomSpacing
          ? random_real(avgAng * pBegin, avgAng * pEnd)
          : pi * avgAng;
        const double rsinT = center[1] + radius * std::sin(ang);
        const double rcosT = center[0] + radius * std::cos(ang);
        pts.push_back(PointType {rcosT, rsinT});
      }
      m_objectMesh.setPoints(pts);
    }

    axom::slic::flushStreams();
    SLIC_ASSERT(m_objectMesh.isValid());
  }

  /// Outputs the object mesh to disk
  void saveMesh(const std::string& filename = "object_mesh")
  {
    SLIC_INFO(
      banner(axom::fmt::format("Saving particle mesh '{}' to disk", filename)));

    m_objectMesh.saveMesh(filename);
  }

private:
  BlueprintParticleMesh m_objectMesh;
  bool m_verbose {false};
};

class QueryMeshWrapper
{
public:
  using Circle = primal::Sphere<double, 2>;

  //!@brief Construct with blueprint mesh.
  QueryMeshWrapper(sidre::Group* group, const std::string& meshFilename)
    : m_queryMesh(group)
  {
    // Test reading in multidomain mesh.
    m_queryMesh.read_blueprint_mesh(meshFilename);
    setupParticleMesh();
  }

  BlueprintParticleMesh& getParticleMesh() { return m_queryMesh; }

  sidre::Group* getBlueprintGroup() const { return m_queryMesh.root_group(); }

  std::string getCoordsetName() const { return m_queryMesh.getCoordsetName(); }

  /// Returns an array containing the positions of the mesh vertices
  template <typename PointArray>
  PointArray getVertexPositions(int domainIdx)
  {
    // SLIC_ERROR("TODO: get a PointArray from a sidre coordset/values group.");
    sidre::Group* cvg = m_queryMesh.domain_group(domainIdx)->getGroup(
      axom::fmt::format("coordsets/{}/values", m_queryMesh.getCoordsetName()));
    int ndim = cvg->getNumViews();
    sidre::View* xv = cvg->getView("x");
    sidre::View* yv = cvg->getView("y");
    sidre::View* zv = ndim == 3 ? cvg->getView("z") : nullptr;
    axom::IndexType npts = xv->getNumElements();
    double* xp = xv->getData();
    double* yp = yv->getData();
    double* zp = zv ? (double*)(zv->getData()) : nullptr;
    double* xyzs[3] {xp, yp, zp};
    PointArray rval(npts, npts);
    for(int d = 0; d < ndim; ++d)
    {
      double* vs = xyzs[d];
      for(int i = 0; i < npts; ++i)
      {
        rval[i][d] = vs[i];
      }
    }
    typename PointArray::value_type pt;
    axom::primal::Point<double, PointArray::value_type::DIMENSION> pt1;
    return rval;
  }

  /// Saves the mesh to disk
  void saveMesh(const std::string& filename)
  {
    SLIC_INFO(
      banner(axom::fmt::format("Saving query mesh '{}' to disk", filename)));

    m_queryMesh.saveMesh(filename);
  }

  void setupParticleMesh()
  {
    {
      m_queryMesh.registerNodalScalarField<axom::IndexType>("cp_rank");
      m_queryMesh.registerNodalScalarField<axom::IndexType>("cp_index");
      m_queryMesh.registerNodalScalarField<double>("cp_distance");
      m_queryMesh.registerNodalVectorField<double>("cp_coords");
    }

    SLIC_ASSERT(m_queryMesh.isValid());
  }

  /// Prints some info about the mesh
  void print_mesh_info() { m_queryMesh.print_mesh_info(); }

  /*!
    @brief Update results from closest point search.
  */
  void update_closest_points(conduit::Node& node)
  {
    bool isMultidomain = conduit::blueprint::mesh::is_multi_domain(node);
// SLIC_ASSERT(m_queryMesh.domain_count() == 1);

    // If query mesh isn't multidomain, create a temporary multidomain representation.
    std::shared_ptr<conduit::Node> tmpNode;
    if(!isMultidomain)
    {
// std::cout<<__WHERE<<"node[fields] before importConduitTree:"<<std::endl; node.fetch_existing("fields").schema().print(); node.fetch_existing("fields").print();
// std::cout<<__WHERE<<"node[fields/cp_coords] before importConduitTree:"<<std::endl; node.fetch_existing("fields/cp_coords").schema().print(); node.fetch_existing("fields/cp_coords").print();
std::cout<<__WHERE<<"node[fields/cp_coords/values] before importConduitTree:"<<std::endl; node.fetch_existing("fields/cp_coords/values").schema().print(); node.fetch_existing("fields/cp_coords/values").print();
      sidre::Group* fg0 = m_queryMesh.domain_group(0)->getGroup("fields");
      sidre::Group* fg0coords = fg0->getGroup("cp_coords");
// std::cout<<__WHERE<<"fg0coords before group importConduitTree:"<<std::endl; fg0coords->print();
      sidre::Group* fg0coordsValues = fg0coords->getGroup("values");
      // bool goodImport = fg0->getGroup("cp_coords/values")->importConduitTree(node.fetch_existing("fields/cp_coords/values"));
      // SLIC_ASSERT(goodImport);
      sidre::Group* fg0rank = fg0->getGroup("cp_rank");
      sidre::View* fg0rankValues = fg0rank->getView("values");
      bool goodImport = fg0->getGroup("cp_rank")->importConduitTree(node.fetch_existing("fields/cp_rank"));
      SLIC_ASSERT(goodImport);
      goodImport = fg0->getGroup("cp_index")->importConduitTree(node.fetch_existing("fields/cp_index"));
      SLIC_ASSERT(goodImport);
      int dim = node.fetch_existing("fields/cp_coords/values").number_of_children();
#if 1
      auto* dst = fg0coords->getGroup("values");
      auto* viewx = fg0coords->getView("values/x");
      auto* viewy = fg0coords->getView("values/y");
      double* dstx = static_cast<double*>(fg0coords->getView("values/x")->getVoidPtr());
      double* dsty = static_cast<double*>(fg0coords->getView("values/y")->getVoidPtr());
      const auto& nd = node.fetch_existing("fields/cp_coords/values");
      double *src = static_cast<double*>(node.fetch_existing("fields/cp_coords/values").data_ptr());
      auto pointCount = node.fetch_existing("fields/cp_coords/values/x").total_bytes_compact();
      axom::copy(dstx, src, dim*pointCount);
#else
      goodImport = fg0->getGroup("cp_distance")->importConduitTree(node.fetch_existing("fields/cp_distance"));
      SLIC_ASSERT(goodImport);
#endif
// std::cout<<__WHERE<<"fg0coords after group importConduitTree:"<<std::endl; fg0coords->print();
      SLIC_ASSERT(goodImport);
    }
    else
    {
#if 0
for(auto &dom : node.children())
{
std::cout<<__WHERE<<"dom[fields/cp_coords] before importConduitTree:"<<std::endl; dom.fetch_existing("fields/cp_coords").schema().print(); dom.fetch_existing("fields/cp_coords").print();
}
      SLIC_ASSERT(node.number_of_children() == m_queryMesh.domain_count());
      bool goodImport = m_queryMesh.root_group()->importConduitTree(node);
      SLIC_ASSERT(goodImport);
for(auto &grp : m_queryMesh.root_group()->groups())
{
std::cout<<__WHERE<<"grp[fields/cp_coords] after importConduitTree:"<<std::endl; grp.getGroup("fields/cp_coords")->print();
}
#endif
    }

    m_queryMesh.reset_group_pointers();
    for(axom::IndexType di = 0; di < m_queryMesh.domain_count(); ++di)
    {
      assert(m_queryMesh.domain_group(di) == m_queryMesh.root_group()->getGroup(di));
#if 1
      assert(m_queryMesh.coords_group(di) == m_queryMesh.domain_group(di)->getGroup("coordsets")->getGroup(m_queryMesh.getCoordsetName()));
      assert(m_queryMesh.topo_group(di) ==
             m_queryMesh.domain_group(di)->getGroup("topologies")->getGroup(m_queryMesh.get_topology_name()));
      assert(m_queryMesh.fields_group(di) == m_queryMesh.domain_group(di)->getGroup("fields"));
#endif
    }
  }

  void importCoordinatesFromConduitTree(sidre::Group *dst, const conduit::Node &src)
  {
  }

  /**
   * Check for error in the search.
   * - check that points within threshold have a closest point
   *   on the object.
   * - check that found closest-point is near its corresponding
   *   closest point on the circle (within tolerance)
   *
   * Return number of errors found on the local mesh partition.
   * Populate "error_flag" field with the number of errors, for
   * visualization.
   *
   * Randomized circle points (--random-spacing switch) can cause
   * false positives, so when it's on, distance inaccuracy is a warning
   * (not an error) for the purpose of checking.
   */
  template <int NDIMS>
  int checkClosestPoints(const Circle& circle, const Input& params)
  {
    using PointType = Circle::PointType;
    using PointArray = axom::Array<PointType>;

    m_queryMesh.registerNodalScalarField<axom::IndexType>("error_flag");

    int sumErrCount = 0;
    int sumWarningCount = 0;
    for(axom::IndexType dIdx = 0; dIdx < m_queryMesh.domain_count(); ++dIdx)
    {
      PointArray queryPts = m_queryMesh.getPoints<NDIMS>(dIdx);

      auto cpCoords =
        m_queryMesh.getNodalVectorField<PointType>("cp_coords", dIdx);

      auto cpIndices =
        m_queryMesh.getNodalScalarField<axom::IndexType>("cp_index", dIdx);

      axom::ArrayView<axom::IndexType> errorFlag =
        m_queryMesh.getNodalScalarField<axom::IndexType>("error_flag", dIdx);

      SLIC_ASSERT(queryPts.size() == cpCoords.size());
      SLIC_ASSERT(queryPts.size() == cpIndices.size());

      if(params.isVerbose())
      {
        SLIC_INFO(axom::fmt::format("Closest points ({}):", cpCoords.size()));
      }

      /*
        Allowable slack is half the arclength between 2 adjacent circle
        points.  A query point on the circle can correctly have that
        closest-distance, even though the analytical distance is zero.
        If spacing is random, distance between adjacent points is not
        predictable, leading to false positives.  We don't claim errors
        for this in when using random.
      */
      const double avgObjectRes =
        2 * M_PI * params.circleRadius / params.circlePoints;
      const double allowableSlack = avgObjectRes / 2;

      using IndexSet = slam::PositionSet<>;
      for(auto i : IndexSet(queryPts.size()))
      {
        bool errf = false;

        const auto& qPt = queryPts[i];
        const auto& cpCoord = cpCoords[i];
        double analyticalDist = std::fabs(circle.computeSignedDistance(qPt));
        const bool closestPointFound = (cpIndices[i] == -1);
        if(closestPointFound)
        {
          if(analyticalDist < params.distThreshold - allowableSlack)
          {
            errf = true;
            SLIC_INFO(
              axom::fmt::format("***Error: Query point {} ({}) is within "
                                "threshold by {} but lacks closest point.",
                                i,
                                qPt,
                                params.distThreshold - analyticalDist));
          }
        }
        else
        {
          if(analyticalDist >= params.distThreshold + allowableSlack)
          {
            errf = true;
            SLIC_INFO(
              axom::fmt::format("***Error: Query point {} ({}) is outside "
                                "threshold by {} but has closest point at {}.",
                                i,
                                qPt,
                                analyticalDist - params.distThreshold,
                                cpCoord));
          }

          if(!axom::utilities::isNearlyEqual(circle.computeSignedDistance(cpCoord),
                                             0.0))
          {
            errf = true;
            SLIC_INFO(axom::fmt::format(
              "***Error: Closest point ({}) for index {} is not on the circle.",
              cpCoords[i],
              i));
          }

          double dist = sqrt(primal::squared_distance(qPt, cpCoord));
          if(!axom::utilities::isNearlyEqual(dist, analyticalDist, allowableSlack))
          {
            if(params.randomSpacing)
            {
              ++sumWarningCount;
              SLIC_INFO(axom::fmt::format(
                "***Warning: Closest distance for index {} is {}, off by {}.",
                i,
                dist,
                dist - analyticalDist));
            }
            else
            {
              errf = true;
              SLIC_INFO(
                axom::fmt::format("***Error: Closest distance for index {} is "
                                  "{}, off by {}.",
                                  i,
                                  dist,
                                  dist - analyticalDist));
            }
          }
        }
        errorFlag[i] = errf;
        sumErrCount += errf;
      }
    }

    SLIC_INFO(axom::fmt::format(
      "Local partition has {} errors, {} warnings in closest distance results.",
      sumErrCount,
      sumWarningCount));

    return sumErrCount;
  }

private:
  BlueprintParticleMesh m_queryMesh;
};

void make_coords_contiguous(conduit::Node& coordValues)
{
  bool isInterleaved = conduit::blueprint::mcarray::is_interleaved(coordValues);
  if(isInterleaved)
  {
    conduit::Node oldValues = coordValues;
    conduit::blueprint::mcarray::to_contiguous(oldValues, coordValues);
  }
}

void make_coords_interleaved(conduit::Node& coordValues)
{
  bool isInterleaved = conduit::blueprint::mcarray::is_interleaved(coordValues);
  if(!isInterleaved)
  {
    conduit::Node oldValues = coordValues;
    conduit::blueprint::mcarray::to_interleaved(oldValues, coordValues);
  }
}

/// Utility function to initialize the logger
void initializeLogger()
{
  // Initialize Logger
  slic::initialize();
  slic::setLoggingMsgLevel(slic::message::Info);

  slic::LogStream* logStream;

#ifdef AXOM_USE_MPI
  std::string fmt = "[<RANK>][<LEVEL>]: <MESSAGE>\n";
  #ifdef AXOM_USE_LUMBERJACK
  const int RLIMIT = 8;
  logStream = new slic::LumberjackStream(&std::cout, MPI_COMM_WORLD, RLIMIT, fmt);
  #else
  logStream = new slic::SynchronizedStream(&std::cout, MPI_COMM_WORLD, fmt);
  #endif
#else
  std::string fmt = "[<LEVEL>]: <MESSAGE>\n";
  logStream = new slic::GenericOutputStream(&std::cout, fmt);
#endif  // AXOM_USE_MPI

  slic::addStreamToAllMsgLevels(logStream);
}

/// Utility function to finalize the logger
void finalizeLogger()
{
  if(slic::isInitialized())
  {
    slic::flushStreams();
    slic::finalize();
  }
}

//------------------------------------------------------------------------------
int main(int argc, char** argv)
{
  MPI_Init(&argc, &argv);
  int my_rank, num_ranks;
  MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);
  MPI_Comm_size(MPI_COMM_WORLD, &num_ranks);

  initializeLogger();
  //slic::setAbortOnWarning(true);

  //---------------------------------------------------------------------------
  // Set up and parse command line arguments
  //---------------------------------------------------------------------------
  Input params;
  axom::CLI::App app {"Driver for distributed distance query"};

  try
  {
    params.parse(argc, argv, app);
  }
  catch(const axom::CLI::ParseError& e)
  {
    int retval = -1;
    if(my_rank == 0)
    {
      retval = app.exit(e);
    }

    MPI_Bcast(&retval, 1, MPI_INT, 0, MPI_COMM_WORLD);
    MPI_Finalize();

    exit(retval);
  }

  // Issue warning about result-checking requiring good resolution.
  if(params.checkResults && params.randomSpacing)
  {
    SLIC_INFO(axom::fmt::format(
      "***Warning: Result-checking may yield false positive (warnings) when "
      "circle points have random spacing.  High resolution helps limit this."
      "We recommend at least 500 points for each radius length unit."));
  }

  constexpr int DIM = 2;

  using PointType = primal::Point<double, DIM>;
  using PointArray = axom::Array<PointType>;
  using IndexSet = slam::PositionSet<>;
  using Circle = primal::Sphere<double, DIM>;

#if defined(AXOM_USE_UMPIRE)
  //---------------------------------------------------------------------------
  // Memory resource.  For testing, choose device memory if appropriate.
  //---------------------------------------------------------------------------
  const std::string umpireResourceName =
    params.policy == RuntimePolicy::seq || params.policy == RuntimePolicy::omp
    ? "HOST"
    :
  #if defined(UMPIRE_ENABLE_DEVICE)
    "DEVICE"
  #elif defined(UMPIRE_ENABLE_UM)
    "UM"
  #elif defined(UMPIRE_ENABLE_PINNED)
    "PINNED"
  #else
    "HOST"
  #endif
    ;
  auto& rm = umpire::ResourceManager::getInstance();
  umpire::Allocator umpireAllocator = rm.getAllocator(umpireResourceName);
#endif

  //---------------------------------------------------------------------------
  // Load/generate object mesh
  //---------------------------------------------------------------------------
  const Circle circle(
    PointType(params.circleCenter.data(), params.circleCenter.size()),
    params.circleRadius);

  sidre::DataStore objectDS;
  ObjectMeshWrapper object_mesh_wrapper(
    objectDS.getRoot()->createGroup("object_mesh", true));
  object_mesh_wrapper.setVerbosity(params.isVerbose());

  {
    SLIC_ASSERT(params.objDomainCountRange[1] >= params.objDomainCountRange[0]);
    const unsigned int omin = params.objDomainCountRange[0];
    const unsigned int omax = params.objDomainCountRange[1];
    const double prob = axom::utilities::random_real(0., 1.);
    int localDomainCount = omin + int(0.5 + prob * (omax - omin));
    object_mesh_wrapper.generateCircleMesh(circle,
                                           params.circlePoints,
                                           localDomainCount,
                                           params.randomSpacing);
  }

  SLIC_INFO_IF(
    params.isVerbose(),
    axom::fmt::format("Object mesh has {} points",
                      object_mesh_wrapper.getParticleMesh().numPoints()));

  object_mesh_wrapper.saveMesh(params.objectFile);
  slic::flushStreams();

  //---------------------------------------------------------------------------
  // Load computational mesh and generate a particle mesh over its nodes
  // These will be used to query the closest points on the object mesh(es)
  //---------------------------------------------------------------------------
  sidre::DataStore queryDS;  // TODO: Need separate stores for object and query?
  QueryMeshWrapper queryMeshWrapper(
    queryDS.getRoot()->createGroup("queryMesh", true),
    params.meshFile);
  // queryMeshWrapper.print_mesh_info();
  const int nMeshPoints = queryMeshWrapper.getParticleMesh().numPoints();

  SLIC_INFO_IF(params.isVerbose(),
               axom::fmt::format("Query mesh has {} points on rank {}",
                                 nMeshPoints,
                                 my_rank));
  slic::flushStreams();

  //---------------------------------------------------------------------------
  // Initialize spatial index for querying points, and run query
  //---------------------------------------------------------------------------

  auto init_str =
    banner(axom::fmt::format("Initializing BVH tree over {} points",
                             params.circlePoints));

  auto query_str =
    banner(axom::fmt::format("Computing closest points for {} query points",
                             nMeshPoints));

  axom::utilities::Timer initTimer(false);
  axom::utilities::Timer queryTimer(false);

  // Convert blueprint representation from sidre to conduit
  conduit::Node object_mesh_node;
  if(object_mesh_wrapper.getParticleMesh().numPoints() > 0)
  {
    object_mesh_wrapper.getBlueprintGroup()->createNativeLayout(object_mesh_node);
  }

  // Put sidre data into Conduit Node.
  conduit::Node queryMeshNode;
std::cout<<__WHERE<<"before createNativeLayout, queryMesh[0][fields]:"<<std::endl; queryMeshWrapper.getBlueprintGroup()->getGroup(0)->getGroup("fields")->print();
  queryMeshWrapper.getBlueprintGroup()->createNativeLayout(queryMeshNode);
std::cout<<__WHERE<<"after createNativeLayout, queryMeshNode[fields]:"<<std::endl; queryMeshNode.schema().print(); queryMeshNode.print();

  // To test with contiguous and interleaved coordinate storage,
  // make half them contiguous.
  for(int di = 0; di < object_mesh_node.number_of_children(); ++di)
  {
    auto& dom = object_mesh_node.child(di);
    if((my_rank + di) % 2 == 1)
    {
      make_coords_contiguous(dom.fetch_existing("coordsets/coords/values"));
    }
  }
  for(int di = 0; di < queryMeshNode.number_of_children(); ++di)
  {
    auto& dom = queryMeshNode.child(di);
    if((my_rank + di) % 2 == 1)
    {
      make_coords_contiguous(dom.fetch_existing("coordsets/coords/values"));
    }
  }

#if 1
  if(object_mesh_node.number_of_children() == 1)
  {
    conduit::Node tmpNode = object_mesh_node[0];
    object_mesh_node.reset();
    object_mesh_node = tmpNode;
  }
#endif

#if 1
  if(queryMeshNode.number_of_children() == 1)
  {
    conduit::Node tmpNode = queryMeshNode[0];
// std::cout<<__WHERE<<conduit::blueprint::mcarray::is_interleaved(queryMeshNode[0].fetch_existing("fields/cp_coords/values")) << std::endl;
// std::cout<<__WHERE<<conduit::blueprint::mcarray::is_interleaved(tmpNode.fetch_existing("fields/cp_coords/values")) << std::endl;
    queryMeshNode.reset();
    queryMeshNode = tmpNode;
// std::cout<<__WHERE<<conduit::blueprint::mcarray::is_interleaved(queryMeshNode.fetch_existing("fields/cp_coords/values")) << std::endl;
std::cout<<__WHERE<<"group(0)[fields] after singledomain:"<<std::endl; queryMeshNode.fetch_existing("fields").schema().print(); queryMeshNode.fetch_existing("fields").print();
  }
#endif

  // Create distributed closest point query object and set some parameters
  quest::DistributedClosestPoint query;
  query.setRuntimePolicy(params.policy);
#if defined(AXOM_USE_UMPIRE)
  query.setAllocatorID(umpireAllocator.getId());
#endif
  query.setMpiCommunicator(MPI_COMM_WORLD, true);
  query.setDimension(DIM);
  query.setVerbosity(params.isVerbose());
  query.setDistanceThreshold(params.distThreshold);
  query.setObjectMesh(object_mesh_node, object_mesh_wrapper.getCoordsetName());

  // Build the spatial index over the object on each rank
  SLIC_INFO(init_str);
  slic::flushStreams();
  initTimer.start();
  query.generateBVHTree();
  initTimer.stop();

if(0){
// std::cout<<__WHERE<<"fields/cp_coords:"<<std::endl;
// make_coords_interleaved(queryMeshNode.fetch_existing("fields/cp_coords/values"));
std::cout<<__WHERE<<"queryMeshNode[fields/cp_coords]:"<<std::endl; queryMeshNode.fetch_existing("fields/cp_coords").schema().print(); queryMeshNode.fetch_existing("fields/cp_coords").print();
double *xptr = (double*)queryMeshNode.fetch_existing("fields/cp_coords/values/x").data_ptr();
double *yptr = (double*)queryMeshNode.fetch_existing("fields/cp_coords/values/y").data_ptr();
int sx = queryMeshNode.fetch_existing("fields/cp_coords/values/x").dtype().number_of_elements();
int sy = queryMeshNode.fetch_existing("fields/cp_coords/values/y").dtype().number_of_elements();
// std::cout<<__WHERE<<"ptr: " << xptr << ' ' << yptr << ' ' << (yptr-xptr) << " s: " << sx << ' ' << sy << std::endl;
for(int i=0; i<sx; ++i) xptr[i] = 10;
for(int j=0; j<sy; ++j) yptr[j] = 11;
}
  // Run the distributed closest point query over the nodes of the computational mesh
  SLIC_INFO(query_str);
  slic::flushStreams();
  queryTimer.start();
// std::cout<<__WHERE<<std::endl;
// queryMeshNode.print();

// std::cout<<__WHERE<<"Before search:"<<std::endl; queryMeshNode.print();
// std::cout<<__WHERE<<"domain(0)[fields] before search:"<<std::endl; queryMeshNode.fetch_existing("fields").schema().print(); queryMeshNode.fetch_existing("fields").print();
  query.computeClosestPoints(queryMeshNode, queryMeshWrapper.getCoordsetName());
// std::cout<<__WHERE<<"domain(0)[fields] after search:"<<std::endl; queryMeshNode.fetch_existing("fields").schema().print(); queryMeshNode.fetch_existing("fields").print();
// std::cout<<__WHERE<<"After search, cp_index:"<<std::endl; queryMeshNode.fetch_existing("fields/cp_index/values").print_detailed();
// std::cout<<__WHERE<<"After search, cp_coords:"<<std::endl; queryMeshNode.fetch_existing("fields/cp_coords/values").print_detailed();
// exit(0);
// queryMeshNode.reset();
  queryTimer.stop();

  auto getMinMax =
    [](double inVal, double& minVal, double& maxVal, double& sumVal) {
      MPI_Allreduce(&inVal, &minVal, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
      MPI_Allreduce(&inVal, &maxVal, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
      MPI_Allreduce(&inVal, &sumVal, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
    };

  // Output some timing stats
  {
    double minInit, maxInit, sumInit;
    getMinMax(initTimer.elapsedTimeInSec(), minInit, maxInit, sumInit);

    double minQuery, maxQuery, sumQuery;
    getMinMax(queryTimer.elapsedTimeInSec(), minQuery, maxQuery, sumQuery);

    SLIC_INFO(axom::fmt::format(
      "Initialization with policy {} took {{avg:{}, min:{}, max:{}}} seconds",
      params.policy,
      sumInit / num_ranks,
      minInit,
      maxInit));
    SLIC_INFO(axom::fmt::format(
      "Query with policy {} took {{avg:{}, min:{}, max:{}}} seconds",
      params.policy,
      sumQuery / num_ranks,
      minQuery,
      maxQuery));
  }
  slic::flushStreams();

  queryMeshWrapper.update_closest_points(queryMeshNode);

  int errCount = 0;
  int localErrCount = 0;
  if(params.checkResults)
  {
    localErrCount = queryMeshWrapper.checkClosestPoints<DIM>(circle, params);
  }
  MPI_Allreduce(&localErrCount, &errCount, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);

  //---------------------------------------------------------------------------
  // Transform closest points to distances and directions
  //---------------------------------------------------------------------------
  using primal::squared_distance;

  // Output some stats about the per-rank query points
  {
    double minPts, maxPts, sumPts;
    getMinMax(nMeshPoints, minPts, maxPts, sumPts);
    SLIC_INFO(
      axom::fmt::format(" Query points: {{total:{}, min:{}, max:{}, avg:{}}}",
                        sumPts,
                        minPts,
                        maxPts,
                        sumPts / num_ranks));
    slic::flushStreams();
  }

  auto& queryMesh = queryMeshWrapper.getParticleMesh();
  PointType nowhere(std::numeric_limits<double>::signaling_NaN());
  const double nodist = std::numeric_limits<double>::signaling_NaN();
  queryMesh.registerNodalScalarField<double>("distance");
  queryMesh.registerNodalVectorField<double>("direction");
  for(axom::IndexType di = 0; di < queryMesh.domain_count(); ++di)
  {
    auto cpCoords = queryMesh.getNodalVectorField<PointType>("cp_coords", di);

    auto cpIndices =
      queryMesh.getNodalScalarField<axom::IndexType>("cp_index", di);

    PointArray qPts = queryMeshWrapper.getVertexPositions<PointArray>(di);
    axom::ArrayView<double> distances =
      queryMesh.getNodalScalarField<double>("distance", di);
    axom::ArrayView<PointType> directions =
      queryMesh.getNodalVectorField<PointType>("direction", di);
    axom::IndexType ptCount = queryMeshWrapper.getParticleMesh().numPoints(di);
    for(auto ptIdx : IndexSet(ptCount))
    {
      const bool has_cp = cpIndices[ptIdx] >= 0;
      const PointType& cp = has_cp ? cpCoords[ptIdx] : nowhere;
      distances[ptIdx] =
        has_cp ? sqrt(squared_distance(qPts[ptIdx], cp)) : nodist;
      directions[ptIdx] =
        PointType(has_cp ? (cp - qPts[ptIdx]).array() : nowhere.array());
    }
  }

// queryMeshNode.print();
  queryMeshNode.reset();

  queryMeshWrapper.saveMesh(params.distanceFile);

  if(errCount)
  {
    SLIC_INFO(axom::fmt::format(" Error exit: {} errors found.", errCount));
  }
  else
  {
    SLIC_INFO("Normal exit.");
  }

  finalizeLogger();
  MPI_Finalize();

  return errCount != 0;
}
