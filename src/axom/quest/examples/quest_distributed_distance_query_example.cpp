// Copyright (c) 2017-2022, Lawrence Livermore National Security, LLC and
// other Axom Project Developers. See the top-level COPYRIGHT file for details.
//
// SPDX-License-Identifier: (BSD-3-Clause)

/*!
 * \file quest_distributed_distance_query_example.cpp
 * \brief Driver for a distributed distance query
 */

// Axom includes
#include "axom/config.hpp"
#include "axom/core.hpp"
#include "axom/slic.hpp"
#include "axom/primal.hpp"
#include "axom/sidre.hpp"
#include "axom/quest.hpp"
#include "axom/slam.hpp"
#include "axom/core/Types.hpp"
#include "axom/core/utilities/WhereMacro.hpp"

#include "conduit_blueprint.hpp"
#include "conduit_blueprint_mpi.hpp"
#include "conduit_relay_io_blueprint.hpp"
#include "conduit_relay_mpi_io_blueprint.hpp"

#include "axom/quest/DistributedClosestPoint.hpp"

#include "axom/fmt.hpp"
#include "axom/CLI11.hpp"

#ifndef AXOM_USE_MFEM
  #error This example requires Axom to be configured with MFEM and the AXOM_ENABLE_MFEM_SIDRE_DATACOLLECTION option
#endif
#include "mfem.hpp"

#ifndef AXOM_USE_MPI
  #error This example requires Axom to be configured with MPI
#endif
#include "mpi.h"

// C/C++ includes
#include <string>
#include <limits>
#include <map>
#include <vector>
#include <cmath>

namespace quest = axom::quest;
namespace slic = axom::slic;
namespace sidre = axom::sidre;
namespace slam = axom::slam;
namespace spin = axom::spin;
namespace primal = axom::primal;
namespace mint = axom::mint;
namespace numerics = axom::numerics;

using RuntimePolicy = axom::quest::DistributedClosestPoint::RuntimePolicy;

// converts the input string into an 80 character string
// padded on both sides with '=' symbols
std::string banner(const std::string& str)
{
  return axom::fmt::format("{:=^80}", str);
}

/// Struct to parse and store the input parameters
struct Input
{
public:
  std::string meshFile;
  std::string distanceFile {"cp_coords"};
  std::string objectFile {"object_mesh"};

  double circleRadius {1.0};
  std::vector<double> circleCenter {0.0, 0.0};
  // TODO: Ensure that circleCenter size matches dimensionality.
  int circlePoints {100};
  RuntimePolicy policy {RuntimePolicy::seq};

  double distThreshold {std::numeric_limits<double>::max()};

  bool checkResults {false};

  bool randomSpacing {true};

  unsigned int minDomainCount {1};
  unsigned int maxDomainCount {1};

private:
  bool m_verboseOutput {false};
  double m_emptyRankProbability {0.};

  // clang-format off
  const std::map<std::string, RuntimePolicy> s_validPolicies
  {
      {"seq", RuntimePolicy::seq}
#if defined(AXOM_USE_RAJA) && defined(AXOM_USE_UMPIRE)
  #ifdef AXOM_USE_OPENMP
    , {"omp", RuntimePolicy::omp}
  #endif
  #ifdef AXOM_USE_CUDA
    , {"cuda", RuntimePolicy::cuda}
  #endif
  #ifdef AXOM_USE_HIP
    , {"hip", RuntimePolicy::hip}
  #endif
#endif
  };
  // clang-format on

public:
  bool isVerbose() const { return m_verboseOutput; }
  double percentEmptyRanks() const { return m_emptyRankProbability; }

  std::string getDCMeshName() const
  {
    using axom::utilities::string::removeSuffix;

    // Remove the parent directories and file suffix
    std::string name = axom::Path(meshFile).baseName();
    name = removeSuffix(name, ".root");

    return name;
  }

  std::string getMdMeshName() const
  {
    using axom::utilities::string::removeSuffix;

    // Remove the parent directories and file suffix
    std::string name = axom::Path(meshFile).baseName();
    name = removeSuffix(name, ".root");

    return name;
  }

  void parse(int argc, char** argv, axom::CLI::App& app)
  {
#if 1
    app.add_option("-m,--mesh-file", meshFile)
      ->description(
        "Path to multidomain computational mesh (generated by conduit)")
      ->check(axom::CLI::ExistingFile);
#else
    app.add_option("-m,--mesh-file", meshFile)
      ->description(
        "Path to computational mesh (generated by MFEMSidreDataCollection)")
      ->check(axom::CLI::ExistingFile);
#endif

    app.add_option("-s,--distance-file", distanceFile)
      ->description("Name of output mesh file containing closest distance.")
      ->capture_default_str();

    app.add_option("-o,--object-file", objectFile)
      ->description("Name of output file containing object mesh.")
      ->capture_default_str();

    app.add_flag("-v,--verbose,!--no-verbose", m_verboseOutput)
      ->description("Enable/disable verbose output")
      ->capture_default_str();

    app.add_option("--empty-rank-probability", m_emptyRankProbability)
      ->description(
        "Probability that a rank's data is empty "
        "(tests code's ability to handle empty ranks)")
      ->check(axom::CLI::Range(0., 1.))
      ->capture_default_str();

    app.add_option("--min-domain-count", minDomainCount)
      ->description(
        "Min number of domains per rank."
        "Defaults to 1")
      ->check(axom::CLI::Range(0, 10))
      ->capture_default_str();

    // TODO: Any way to set min and max together and require max >= min?
    app.add_option("--max-domain-count", maxDomainCount)
      ->description(
        "Max number of domains per rank."
        "Defaults to 1")
      ->check(axom::CLI::Range(0, 10))
      ->capture_default_str();

    app.add_option("-r,--radius", circleRadius)
      ->description("Radius for circle")
      ->capture_default_str();

    auto* circle_options =
      app.add_option_group("circle",
                           "Options for setting up the circle of points");
    circle_options->add_option("--center", circleCenter)
      ->description("Center for object (x,y[,z])")
      ->expected(2, 3);

    app.add_flag("--random-spacing,!--no-random-spacing", randomSpacing)
      ->description("Enable/disable random spacing of circle points")
      ->capture_default_str();

    app.add_option("-d,--dist-threshold", distThreshold)
      ->check(axom::CLI::NonNegativeNumber)
      ->description("Distance threshold to search")
      ->capture_default_str();

    app.add_option("-n,--num-samples", circlePoints)
      ->description("Number of points for circle")
      ->capture_default_str();

    app.add_option("-p, --policy", policy)
      ->description("Set runtime policy for point query method")
      ->capture_default_str()
      ->transform(axom::CLI::CheckedTransformer(s_validPolicies));

    app.add_flag("-c,--check-results,!--no-check-results", checkResults)
      ->description(
        "Enable/disable checking results against analytical solution")
      ->capture_default_str();

    app.get_formatter()->column_width(60);

    // could throw an exception
    app.parse(argc, argv);

    slic::setLoggingMsgLevel(m_verboseOutput ? slic::message::Debug
                                             : slic::message::Info);
  }
};

/**
 *  \brief Simple wrapper to a blueprint particle mesh
 *
 *  Given a sidre Group, creates the stubs for a mesh blueptint particle mesh
 */
struct BlueprintParticleMesh
{
public:
  using Point2D = primal::Point<double, 2>;
  using Point3D = primal::Point<double, 3>;
  using PointArray2D = axom::Array<Point2D>;
  using PointArray3D = axom::Array<Point3D>;

  explicit BlueprintParticleMesh(sidre::Group* group = nullptr,
                                 const std::string& coordset = "coords",
                                 const std::string& topology = "mesh")
    : m_coordsetName(coordset)
    , m_topologyName(topology)
    , m_group(group)
    , m_domainGroups()
  {
    MPI_Comm_rank(MPI_COMM_WORLD, &m_rank);
    MPI_Comm_size(MPI_COMM_WORLD, &m_nranks);
  }

  /// Gets the root group for this mesh blueprint
  sidre::Group* rootGroup() const { return m_group; }

  /// Gets number of domains in the multidomain particle mesh
  axom::IndexType domain_count() const { return m_group->getNumGroups(); }

  /// Gets a domain group.
  sidre::Group* domain_group(axom::IndexType groupIdx) const
  {
    SLIC_ASSERT(size_t(groupIdx) < m_domainGroups.size());
    return m_domainGroups[groupIdx];
  }
  /// Gets the parent group for the blueprint coordinate set
  sidre::Group* coordsGroup(axom::IndexType groupIdx) const { return m_coordsGroups[groupIdx]; }
  /// Gets the parent group for the blueprint mesh topology
  sidre::Group* topoGroup(axom::IndexType groupIdx) const { return m_topoGroups[groupIdx]; }

  const std::string& getCoordsetName() const { return m_coordsetName; }

  /// Gets the MPI rank for this mesh
  int getRank() const { return m_rank; }
  /// Gets the number of ranks in the problem
  int getNumRanks() const { return m_nranks; }

  /// Returns true if points have been added to the particle mesh
  bool hasPoints() const
  {
    // return m_coordsGroup != nullptr && m_coordsGroup->hasView("values/x");
    for(auto *cg : m_coordsGroups)
    {
      if(cg != nullptr && cg->hasView("values/x")) return true;
    }
    return false;
  }

  /// Returns the number of points in a particle mesh domain
  int numPoints(axom::IndexType dIdx) const
  {
    int rval = 0;
    auto *cg = m_coordsGroups[dIdx];
    //BTNG: The following if-check is probably not a use-case
    if(cg != nullptr && cg->hasView("values/x"))
    {
      rval = cg->getView("values/x")->getNumElements();
    }
    return rval;
  }
  /// Returns the number of points in the particle mesh
  int numPoints() const
  {
    int rval = 0;
    const axom::IndexType domCount = domain_count();
    for(axom::IndexType dIdx = 0; dIdx < domCount; ++dIdx)
    {
      rval += numPoints(dIdx);
    }
    return rval;
  }

  int dimension() const { return m_dimension; }

  /*!
    @brief Read a blueprint mesh.
  */
  void read_blueprint_mesh(const std::string& meshFilename)
  {
    SLIC_ASSERT(!meshFilename.empty());

    m_domainGroups.clear();
    m_coordsGroups.clear();
    m_topoGroups.clear();
    m_fieldsGroups.clear();

    conduit::Node mdMesh;
    conduit::relay::mpi::io::blueprint::load_mesh(meshFilename, mdMesh, MPI_COMM_WORLD);
    assert(conduit::blueprint::mesh::is_multi_domain(mdMesh));
    conduit::index_t domCount = conduit::blueprint::mesh::number_of_domains(mdMesh);
#if 0
    std::cout<<__WHERE<<"rank " << m_rank << " has " << domCount << " domains." << std::endl;
#if 1
    for(auto &d : mdMesh.children())
    {
      std::cout<<__WHERE<<"rank " << m_rank << " has domain " << d.name() << std::endl;
    }
    std::cout << "Multidomain mesh from " << meshFilename << std::endl;
    mdMesh.print();
#endif
#endif
if(0){
auto &mdCoords = mdMesh.child(0)["coordsets/coords/values"];
conduit::Node mdCoords1 = mdCoords;
conduit::blueprint::mcarray::to_interleaved(mdCoords1, mdCoords);
// std::cout<<__WHERE<<"mdCoords: interleaved=" << conduit::blueprint::mcarray::is_interleaved(mdCoords) << " contiguous=" << mdCoords.is_contiguous() <<std::endl;  mdCoords.print();
// std::cout<<__WHERE<<"mdCoords1: interleaved=" << conduit::blueprint::mcarray::is_interleaved(mdCoords1) << " contiguous=" << mdCoords1.is_contiguous() <<std::endl;  mdCoords1.print();
// mdMesh.child(0)["coordsets/coords/values"] = mdCoords1;
// mdMesh.child(0)["coordsets/coords/values"].print();
// auto &mdCoords2 = mdMesh.child(0)["coordsets/coords/values"];
// std::cout<<__WHERE<<"mdCoords2: interleaved=" << conduit::blueprint::mcarray::is_interleaved(mdCoords2) << " contiguous=" << mdCoords2.is_contiguous() <<std::endl;  mdCoords2.print();
}

    if(domCount > 0)
    {
      const conduit::Node coordsetNode = mdMesh[0].fetch_existing("coordsets").fetch_existing(m_coordsetName);
      m_dimension = conduit::blueprint::mesh::coordset::dims(coordsetNode);
// std::cout<<__WHERE<< "is_contiguous = " << coordsetNode["values"].is_contiguous() << std::endl;
// std::cout<<__WHERE<< "is_interleaved = " << conduit::blueprint::mcarray::is_interleaved(coordsetNode["values"]) << std::endl;
    }
    MPI_Allreduce(MPI_IN_PLACE, &m_dimension, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
    SLIC_ASSERT(m_dimension > 0);

    if(domCount > 0)
    {
    // Put mdMesh into sidre Group.
    bool goodImport = m_group->importConduitTree(mdMesh, false);
// std::cout<<__WHERE<<"rank " << m_rank << " goodImport " << goodImport << std::endl;
// std::cout<<__WHERE<<"rank " << m_rank << " valid " << valid << std::endl;
// std::cout<<__WHERE<<"rank " << m_rank << " m_group:" << std::endl;
    SLIC_ASSERT(goodImport);
// conduit::Node checkNode;
// m_group->createNativeLayout(checkNode);
// conduit::Node diff;
// mdMesh.diff(checkNode, diff);
// std::cout<<__WHERE<<"Diff between mdMesh and checkNode: "<<std::endl; diff.print();
// std::cout<<__WHERE<<"mdMesh: "<<std::endl; mdMesh.print();
// std::cout<<__WHERE<<"checkNode: "<<std::endl; checkNode.print();
// std::cout<<__WHERE<<"mdMesh.schema(): "<<std::endl; mdMesh.schema().print();
// std::cout<<__WHERE<<"checkNode.schema(): "<<std::endl; checkNode.schema().print();
// std::cout<<__WHERE<<"m_group: "<<std::endl; m_group->print(std::cout);
// auto &checkCoords = checkNode.child(0)["coordsets/coords/values"];
// std::cout<<__WHERE<<"checkCoords: interleaved=" << conduit::blueprint::mcarray::is_interleaved(checkCoords) << " contiguous=" << checkCoords.is_contiguous() <<std::endl;  checkCoords.print();
// auto &mdCoords = mdMesh.child(0)["coordsets/coords/values"];
// std::cout<<__WHERE<<"mdCoords: interleaved=" << conduit::blueprint::mcarray::is_interleaved(mdCoords) << " contiguous=" << mdCoords.is_contiguous() <<std::endl;  mdCoords.print();
    }

    bool valid = isValid();
    SLIC_ASSERT(valid);

    m_domainGroups.resize(domCount, nullptr);
    m_coordsGroups.resize(domCount, nullptr);
    m_topoGroups.resize(domCount, nullptr);
    m_fieldsGroups.resize(domCount, nullptr);
    for(conduit::index_t di = 0; di < domCount; ++di)
    {
      m_domainGroups[di] = m_group->getGroup(di);
      m_coordsGroups[di] = m_domainGroups[di]->getGroup("coordsets")->getGroup(m_coordsetName);
      m_topoGroups[di] = m_domainGroups[di]->getGroup("topologies")->getGroup(m_topologyName);
      m_fieldsGroups[di] = m_domainGroups[di]->getGroup("fields");
// std::cout << __FILE__<<':'<<__LINE__<< "m_coordsGroup["<<di<<"]:"<<std::endl; m_coordsGroups[di]->print();
    }
  }

  /*!  @brief Set the coordinate data from an array of primal Points

    The points are assigned to a new domain (in the multidomain context).

    This method is for manually creating the mesh.  Don't use it if
    the mesh is read in.
  */
  template <int NDIMS>
  void setPoints(const axom::Array<primal::Point<double, NDIMS>>& pts)
  {
    axom::IndexType domainIdx = createBlueprintStubs();
    SLIC_ASSERT(m_domainGroups[domainIdx] != nullptr);

    const int SZ = pts.size();

    if(m_dimension == -1) { m_dimension = NDIMS; }
    else { SLIC_ASSERT(NDIMS == m_dimension); }

    // lamda to create a strided view into the buffer
    // uses workaround for empty meshes since apply() requires size > 0
    auto createAndApplyView = [=](sidre::Group* grp,
                                  const std::string& path,
                                  sidre::Buffer* buf,
                                  int dim,
                                  int sz) {
      if(sz > 0)
      {
        grp->createView(path)->attachBuffer(buf)->apply(sz, dim, NDIMS);
      }
      else
      {
        grp->createViewAndAllocate(path, sidre::DOUBLE_ID, 0);
      }
    };

    // create views into a shared buffer for the coordinates, with stride NDIMS
    {
      auto* buf = m_domainGroups[domainIdx]->getDataStore()
                    ->createBuffer(sidre::DOUBLE_ID, NDIMS * SZ)
                    ->allocate();

      createAndApplyView(m_coordsGroups[domainIdx], "values/x", buf, 0, SZ);
      if(NDIMS > 1)
      {
        createAndApplyView(m_coordsGroups[domainIdx], "values/y", buf, 1, SZ);
      }
      if(NDIMS > 2)
      {
        createAndApplyView(m_coordsGroups[domainIdx], "values/z", buf, 2, SZ);
      }

      // copy coordinate data into the buffer
      const std::size_t nbytes = sizeof(double) * SZ * NDIMS;
      axom::copy(buf->getVoidPtr(), pts.data(), nbytes);
    }

    // set the default connectivity
    // Maybe be required by an old version of visit.  May not be needed by newer versions of visit.
    sidre::Array<int> arr(m_topoGroups[domainIdx]->createView("elements/connectivity"), SZ, SZ);
    for(int i = 0; i < SZ; ++i)
    {
      arr[i] = i;
    }
  }
#if 1
  template <int NDIMS>
  axom::Array<primal::Point<double, NDIMS>> getPoints(int domainIdx)
  {
    // This code is untested and currently unused.
    auto* cGroup = m_coordsGroups[domainIdx];
    auto* xView = cGroup->getView("values/x");
    auto* yView = cGroup->getView("values/y");
    auto* zView = NDIMS >= 3 ? cGroup->getView("values/z") : nullptr;
    const auto ptCount = xView->getNumElements();
    assert(xView->getStride() == 1);
    assert(yView->getStride() == 1);
    assert(zView == nullptr || zView->getStride() == 1);
    double *xs = xView->getArray();
    double *ys = yView->getArray();
    double *zs = zView ? (double*)(zView->getArray()) : nullptr;

    using PointType = primal::Point<double, NDIMS>;
    axom::Array<PointType> pts;
    pts.resize(ptCount);
    for(int i = 0; i < ptCount; ++i) { pts[i][0] = xs[i]; }
    for(int i = 0; i < ptCount; ++i) { pts[i][1] = ys[i]; }
    if(NDIMS == 3)
    {
      for(int i = 0; i < ptCount; ++i) { pts[i][0] = zs[i]; }
    }
    return pts;
  }
#endif

  template <typename T>
  void registerNodalScalarField(const std::string& fieldName)
  {
#if 0
    // Disabling this assertion because we now allow zero domains.
    SLIC_ASSERT_MSG(hasPoints(),
                    "Cannot register a field with the BlueprintParticleMesh "
                    "before adding points");
#endif

    for(axom::IndexType dIdx = 0; dIdx < domain_count(); ++ dIdx)
    {
      auto* fld = m_fieldsGroups[dIdx]->createGroup(fieldName);
      fld->createViewString("association", "vertex");
      fld->createViewString("topology", m_topoGroups[dIdx]->getName());
      fld->createViewAndAllocate("values",
                                 sidre::detail::SidreTT<T>::id,
                                 numPoints(dIdx));
    }
  }

  template <typename T>
  void registerNodalVectorField(const std::string& fieldName)
  {
#if 0
    // Disabling this assertion because we now allow zero domains.
    SLIC_ASSERT_MSG(hasPoints(),
                    "Cannot register a field with the BlueprintParticleMesh "
                    "before adding points");
#endif

    const int DIM = dimension();
    for(axom::IndexType dIdx = 0; dIdx < domain_count(); ++ dIdx)
    {
      const int SZ = numPoints(dIdx);

      auto* fld = m_fieldsGroups[dIdx]->createGroup(fieldName);
      fld->createViewString("association", "vertex");
      fld->createViewString("topology", m_topoGroups[dIdx]->getName());

      // create views into a shared buffer for the coordinates, with stride NDIMS
      auto* buf = m_domainGroups[dIdx]->getDataStore()
        ->createBuffer(sidre::detail::SidreTT<T>::id, DIM * SZ)
        ->allocate();
      switch(DIM)
      {
      case 3:
        fld->createView("values/x")->attachBuffer(buf)->apply(SZ, 0, DIM);
        fld->createView("values/y")->attachBuffer(buf)->apply(SZ, 1, DIM);
        fld->createView("values/z")->attachBuffer(buf)->apply(SZ, 2, DIM);
        break;
      case 2:
        fld->createView("values/x")->attachBuffer(buf)->apply(SZ, 0, DIM);
        fld->createView("values/y")->attachBuffer(buf)->apply(SZ, 1, DIM);
        break;
      default:
        fld->createView("values/x")->attachBuffer(buf)->apply(SZ, 0, DIM);
        break;
      }
    }
  }

  bool hasField(const std::string& fieldName,
                int domainIdx = 0) const
  {
    return m_fieldsGroups[domainIdx]->hasGroup(fieldName);
  }

  template <typename T>
  axom::ArrayView<T> getNodalScalarField(const std::string& fieldName,
                                         int domainIdx)
  {
#if 0
    // Disabling this assertion because we now allow zero domains.
    SLIC_ASSERT_MSG(hasPoints(),
                    "Cannot extract a field from the BlueprintParticleMesh "
                    "before adding points");
#endif
    SLIC_ASSERT_MSG(domainIdx >= 0 && size_t(domainIdx) < m_domainGroups.size(),
                    axom::fmt::format("Rank {} has no domain {}, only {} domains",
                                      m_rank, domainIdx, m_domainGroups.size()));

    T* data = hasField(fieldName)
      ? static_cast<T*>(
          m_fieldsGroups[domainIdx]->getView(axom::fmt::format("{}/values", fieldName))
            ->getVoidPtr())
      : nullptr;

    return axom::ArrayView<T>(data, numPoints(domainIdx));
  }

  template <typename T>
  axom::ArrayView<T> getNodalVectorField(const std::string& fieldName,
                                         int domainIdx)
  {
#if 0
    // Disabling this assertion because we now allow zero domains.
    SLIC_ASSERT_MSG(hasPoints(),
                    "Cannot extract a field from the BlueprintParticleMesh "
                    "before adding points");
#endif
    SLIC_ASSERT_MSG(domainIdx >= 0 && size_t(domainIdx) < m_domainGroups.size(),
                    axom::fmt::format("Rank {} has no domain {}, only {} domains",
                                      m_rank, domainIdx, m_domainGroups.size()));

    // Note: the implementation currently assumes that the field data is
    // interleaved, so it is safe to get a pointer to the beginning of the
    // x-coordinate's data. This will be relaxed in the future, and we will
    // need to modify this implementation accordingly.
    T* data = hasField(fieldName)
      ? static_cast<T*>(
          m_fieldsGroups[domainIdx]->getView(axom::fmt::format("{}/values/x", fieldName))
            ->getVoidPtr())
      : nullptr;

    return axom::ArrayView<T>(data, numPoints(domainIdx));
  }

  /// Checks whether the blueprint is valid and prints diagnostics
  bool isValid() const
  {
    {
      conduit::Node meshNode;
      m_group->createNativeLayout(meshNode);
      conduit::Node info;
      if(!conduit::blueprint::mpi::verify("mesh", meshNode, info, MPI_COMM_WORLD))
      {
        SLIC_INFO("Invalid blueprint for particle mesh: \n" << info.to_yaml());
        slic::flushStreams();
        return false;
      }
      // info.print();
    }
    return true;
  }

  /// Outputs the particle mesh to disk
  void saveMesh(const std::string& filename)
  {
    if(1)
    {
      conduit::Node meshNode;
      m_group->createNativeLayout(meshNode);
      conduit::relay::mpi::io::blueprint::save_mesh(meshNode,
                                                    filename,
                                                    "hdf5",
                                                    MPI_COMM_WORLD);
    }
    else
    {
      // This didn't write an object mesh that I could see with visit.
      auto* ds = m_group->getDataStore();
      sidre::IOManager writer(MPI_COMM_WORLD);
      writer.write(ds->getRoot(), m_nranks, filename, "sidre_hdf5");

      MPI_Barrier(MPI_COMM_WORLD);

      // m_group->print();
      // Add the bp index to the root file
      writer.writeBlueprintIndexToRootFile(ds,
                                           m_group->getName(),
                                           filename + ".root",
                                           "object_mesh"); // m_domainGroups[0]->getPathName());
    }
  }

  void print_mesh_info() const
  {
    // Copy to conduit::Node.  It's output is easier to read, especially in parallel.
    conduit::Node meshNode;
    m_group->createNativeLayout(meshNode);
    meshNode.print();
  }

private:
  /// Creates blueprint stubs for this mesh
  // for the "coordset", "topologies", "fields" and "state"
  // Return the domain index created.
  axom::IndexType createBlueprintStubs()
  {
    SLIC_ASSERT(m_group != nullptr);

    auto* domainGroup = m_group->createUnnamedGroup();

    auto *coordsGroup = domainGroup->createGroup("coordsets")->createGroup(m_coordsetName);
    coordsGroup->createViewString("type", "explicit");
    coordsGroup->createGroup("values");

    auto *topoGroup = domainGroup->createGroup("topologies")->createGroup(m_topologyName);
    topoGroup->createViewString("coordset", m_coordsetName);
    topoGroup->createViewString("type", "unstructured");
    topoGroup->createViewString("elements/shape", "point");

    auto *fieldsGroup = domainGroup->createGroup("fields");

    domainGroup->createViewScalar<axom::int64>("state/domain_id", m_rank);

    m_domainGroups.push_back(domainGroup);
    m_coordsGroups.push_back(coordsGroup);
    m_topoGroups.push_back(topoGroup);
    m_fieldsGroups.push_back(fieldsGroup);

    return axom::IndexType(m_domainGroups.size() - 1);
  }

private:
  const std::string m_coordsetName;
  const std::string m_topologyName;
  /// Parent group for the entire mesh
  sidre::Group* m_group;
  /// Group for each domain in multidomain mesh
  std::vector<sidre::Group*> m_domainGroups;

  std::vector<sidre::Group*> m_coordsGroups;
  std::vector<sidre::Group*> m_topoGroups;
  std::vector<sidre::Group*> m_fieldsGroups;

  int m_rank;
  int m_nranks;
  int m_dimension {-1};
};  // BlueprintParticleMesh

/**
 * Helper class to generate a mesh blueprint-conforming particle mesh for the input object.
 * The mesh is represented using a Sidre hierarchy
 */
class ObjectMeshWrapper
{
public:
  using Circle = primal::Sphere<double, 2>;

  ObjectMeshWrapper(sidre::Group* group) : m_objectMesh(group)
  {
    SLIC_ASSERT(group != nullptr);
  }

  BlueprintParticleMesh& getParticleMesh() { return m_objectMesh; }

  /// Get a pointer to the root group for this mesh
  sidre::Group* getBlueprintGroup() const { return m_objectMesh.rootGroup(); }

  std::string getCoordsetName() const
  {
    return m_objectMesh.getCoordsetName();
  }

  void setVerbosity(bool verbose) { m_verbose = verbose; }

  /**
   * Generates a collection of \a numPoints points along a circle.
   * Point spacing can be random (default) or uniform.
   */
  void generateCircleMesh(const Circle& circle,
                          int totalNumPoints,
                          int localDomainCount,
                          bool randomSpacing = true)
  {
    using axom::utilities::random_real;

    constexpr int DIM = 2;
    using PointType = primal::Point<double, DIM>;
    using PointArray = axom::Array<PointType>;

    int rank = m_objectMesh.getRank();
    int nranks = m_objectMesh.getNumRanks();

    // perform scan on ranks to compute totalNumPoints, thetaStart and thetaEnd
    axom::Array<int> sums(nranks, nranks);
    {
      axom::Array<int> indivDomainCounts(nranks, nranks);
      indivDomainCounts.fill(-1);
      MPI_Allgather(&localDomainCount, 1, MPI_INT, indivDomainCounts.data(), 1,
                    MPI_INT, MPI_COMM_WORLD);

      SLIC_DEBUG_IF(
        m_verbose,
        axom::fmt::format("After all gather: [{}]", axom::fmt::join(indivDomainCounts, ",")));

      sums[0] = indivDomainCounts[0];
      for(int i = 1; i < nranks; ++i)
      {
        sums[i] = sums[i - 1] + indivDomainCounts[i];
      }
      // If no rank has any domains, force last one to 1 domain.
      if(sums[nranks - 1] == 0)
      {
        sums[nranks - 1] = 1;
        if(rank == nranks - 1)
        {
          localDomainCount = 1;
        }
      }
    }

    SLIC_DEBUG_IF(
      m_verbose,
      axom::fmt::format("After scan: [{}]", axom::fmt::join(sums, ",")));

    int globalDomainCount = sums[nranks - 1];
    totalNumPoints = std::max(totalNumPoints, globalDomainCount);
    int ptsPerDomain = totalNumPoints / globalDomainCount;
    int domainsWithExtraPt = totalNumPoints % globalDomainCount;

    int myDomainBegin = rank == 0 ? 0 : sums[rank - 1];
    int myDomainEnd = sums[rank];
    assert(myDomainEnd-myDomainBegin == localDomainCount);

    double radius = circle.getRadius();
    const auto& center = circle.getCenter();
    const double avgAng = 2. * M_PI / totalNumPoints;

    for(int di=myDomainBegin; di<myDomainEnd; ++di)
    {
      int pBegin = di * ptsPerDomain + std::min(di, domainsWithExtraPt);
      int pEnd =
        (di + 1) * ptsPerDomain + std::min((di + 1), domainsWithExtraPt);
      int domainPointCount = pEnd - pBegin;
      PointArray pts(0, domainPointCount);

      for(int pi = pBegin; pi < pEnd; ++pi)
      {
        const double ang = randomSpacing
          ? random_real(avgAng * pBegin, avgAng * pEnd)
          : pi * avgAng;
        const double rsinT = center[1] + radius * std::sin(ang);
        const double rcosT = center[0] + radius * std::cos(ang);
        pts.push_back(PointType {rcosT, rsinT});
      }
      m_objectMesh.setPoints(pts);
// std::cout<<__WHERE<< "rank " << rank << " got " << pts.size() << " circle points from domain (global index) " << di << std::endl;
    }

    axom::slic::flushStreams();
    SLIC_ASSERT(m_objectMesh.isValid());
  }

  /// Outputs the object mesh to disk
  void saveMesh(const std::string& filename = "object_mesh")
  {
    SLIC_INFO(banner(
      axom::fmt::format("Saving particle mesh '{}' to disk", filename)));

    m_objectMesh.saveMesh(filename);
  }

private:
  BlueprintParticleMesh m_objectMesh;
  bool m_verbose {false};
};

class NewQueryMeshWrapper
{
public:
  using Circle = primal::Sphere<double, 2>;

  //!@brief Construct with MFEM mesh.
  NewQueryMeshWrapper(sidre::Group* group, const std::string& meshFilename)
    : m_queryMesh(group)
  {
    // Test reading in multidomain mesh.
    m_queryMesh.read_blueprint_mesh(meshFilename);
    setupParticleMesh();
  }

  BlueprintParticleMesh& getParticleMesh() { return m_queryMesh; }

  sidre::Group* getBlueprintGroup() const { return m_queryMesh.rootGroup(); }

  std::string getCoordsetName() const
  {
    return m_queryMesh.getCoordsetName();
  }

  /// Returns an array containing the positions of the mesh vertices
  template <typename PointArray>
  PointArray getVertexPositions(int domainIdx)
  {
    // SLIC_ERROR("TODO: get a PointArray from a sidre coordset/values group.");
// sidre::Group* cg = m_queryMesh.coordsGroup(domainIdx);
// cg->print(); std::cout << std::endl;
    sidre::Group* cvg = m_queryMesh.domain_group(domainIdx)->getGroup(axom::fmt::format("coordsets/{}/values", m_queryMesh.getCoordsetName()));
    int ndim = cvg->getNumViews();
    sidre::View* xv = cvg->getView("x");
    sidre::View* yv = cvg->getView("y");
    sidre::View* zv = ndim == 3 ? cvg->getView("z") : nullptr;
    axom::IndexType npts = xv->getNumElements();
    double* xp = xv->getData();
    double* yp = yv->getData();
    double* zp = zv ? (double*)(zv->getData()) : nullptr;
    double *xyzs[3] {xp, yp, zp};
    PointArray rval(npts, npts);
    for(int d = 0; d < ndim; ++d)
    {
      double *vs = xyzs[d];
      for(int i=0; i< npts; ++i)
      {
        rval[i][d] = vs[i];
      }
    }
    typename PointArray::value_type pt;
    axom::primal::Point<double, PointArray::value_type::DIMENSION> pt1;
    return rval;
  }

#if 0
  /// Returns an array containing the positions of the mesh vertices
  template <int DIM>
  axom::Array<axom::primal::Point<double,DIM>> _getVertexPositions(int domainIdx)
  {
    auto tmpRval = m_queryMesh.getNodalVectorField<axom::primal::Point<double,DIM>>("coords", domainIdx);
    // axom::Array<axom::primal::Point<double,DIM>> rval = m_queryMesh.getNodalVectorField<axom::primal::Point<double,DIM>>("coords", domainIdx);
    axom::Array<axom::primal::Point<double,DIM>> rval = tmpRval;
    return rval;
  }
#endif

  /// Saves the data collection (MFEM query mesh) to disk
  void saveMesh()
  {
    SLIC_ERROR(__WHERE "Incomplete code");
  }

  void setupParticleMesh()
  {
    {
#if 0
      SLIC_ERROR(__WHERE "Incomplete code");
      using PointArray2D = axom::Array<primal::Point<double, 2>>;
      using PointArray3D = axom::Array<primal::Point<double, 3>>;

      // Points are already in m_queryMesh via read_blueprint_mesh
      int DIM = 2;
      switch(DIM)
      {
      case 2:
        m_queryMesh.setPoints<2>(getVertexPositions<PointArray2D>());
        break;
      case 3:
        m_queryMesh.setPoints<3>(getVertexPositions<PointArray3D>());
        break;
      }
#endif

      m_queryMesh.registerNodalScalarField<axom::IndexType>("cp_rank");
      m_queryMesh.registerNodalScalarField<axom::IndexType>("cp_index");
      m_queryMesh.registerNodalScalarField<double>("cp_distance");
      m_queryMesh.registerNodalVectorField<double>("cp_coords");
    }

    SLIC_ASSERT(m_queryMesh.isValid());
  }

  /// Prints some info about the mesh
  void print_mesh_info()
  {
    m_queryMesh.print_mesh_info();
  }

  /**
   * Check for error in the search.
   * - check that points within threshold have a closest point
   *   on the object.
   * - check that found closest-point is near its corresponding
   *   closest point on the circle (within tolerance)
   *
   * Return number of errors found on the local mesh partition.
   * Populate "error_flag" field with the number of errors, for
   * visualization.
   *
   * Randomized circle points (--random-spacing switch) can cause
   * false positives, so when it's on, distance inaccuracy is a warning
   * (not an error) for the purpose of checking.
   */
  template <int NDIMS>
  int checkClosestPoints(const Circle& circle, const Input& params)
  {
    using PointType = Circle::PointType;
    using PointArray = axom::Array<PointType>;

    m_queryMesh.registerNodalScalarField<axom::IndexType>("error_flag");

    int sumErrCount = 0;
    int sumWarningCount = 0;
    for(axom::IndexType dIdx = 0; dIdx < m_queryMesh.domain_count(); ++dIdx)
    {
      PointArray queryPts = m_queryMesh.getPoints<NDIMS>(dIdx);

      auto cpCoords =
        m_queryMesh.getNodalVectorField<PointType>("cp_coords", dIdx);

      auto cpIndices =
        m_queryMesh.getNodalScalarField<axom::IndexType>("cp_index", dIdx);

      axom::ArrayView<axom::IndexType> errorFlag =
        m_queryMesh.getNodalScalarField<axom::IndexType>("error_flag", dIdx);

      SLIC_ASSERT(queryPts.size() == cpCoords.size());
      SLIC_ASSERT(queryPts.size() == cpIndices.size());

      if(params.isVerbose())
      {
        SLIC_INFO(axom::fmt::format("Closest points ({}):", cpCoords.size()));
      }

      /*
        Allowable slack is half the arclength between 2 adjacent circle
        points.  A query point on the circle can correctly have that
        closest-distance, even though the analytical distance is zero.
        If spacing is random, distance between adjacent points is not
        predictable, leading to false positives.  We don't claim errors
        for this in when using random.
      */
      const double avgObjectRes =
        2 * M_PI * params.circleRadius / params.circlePoints;
      const double allowableSlack = avgObjectRes / 2;

#if 1
      // SLIC_ERROR(__WHERE "Incomplete code in checkClosestPoints");
      using IndexSet = slam::PositionSet<>;
      for(auto i : IndexSet(queryPts.size()))
      {
        bool errf = false;

        const auto& qPt = queryPts[i];
        const auto& cpCoord = cpCoords[i];
        double analyticalDist = std::fabs(circle.computeSignedDistance(qPt));
        const bool closestPointFound = (cpIndices[i] == -1);
        if(closestPointFound)
        {
          if(analyticalDist < params.distThreshold - allowableSlack)
          {
            errf = true;
            SLIC_INFO(
              axom::fmt::format("***Error: Query point {} ({}) is within "
                                "threshold by {} but lacks closest point.",
                                i,
                                qPt,
                                params.distThreshold - analyticalDist));
          }
        }
        else
        {
          if(analyticalDist >= params.distThreshold + allowableSlack)
          {
            errf = true;
            SLIC_INFO(
              axom::fmt::format("***Error: Query point {} ({}) is outside "
                                "threshold by {} but has closest point at {}.",
                                i,
                                qPt,
                                analyticalDist - params.distThreshold,
                                cpCoord));
          }

          if(!axom::utilities::isNearlyEqual(circle.computeSignedDistance(cpCoord),
                                             0.0))
          {
            errf = true;
            SLIC_INFO(axom::fmt::format(
                        "***Error: Closest point ({}) for index {} is not on the circle.",
                        cpCoords[i],
                        i));
          }

          double dist = sqrt(primal::squared_distance(qPt, cpCoord));
          if(!axom::utilities::isNearlyEqual(dist, analyticalDist, allowableSlack))
          {
            if(params.randomSpacing)
            {
              ++sumWarningCount;
              SLIC_INFO(axom::fmt::format(
                          "***Warning: Closest distance for index {} is {}, off by {}.",
                          i,
                          dist,
                          dist - analyticalDist));
            }
            else
            {
              errf = true;
              SLIC_INFO(
                axom::fmt::format("***Error: Closest distance for index {} is "
                                  "{}, off by {}.",
                                  i,
                                  dist,
                                  dist - analyticalDist));
            }
          }
        }
        errorFlag[i] = errf;
        sumErrCount += errf;
      }
#endif
    }

    SLIC_INFO(axom::fmt::format(
      "Local partition has {} errors, {} warnings in closest distance results.",
      sumErrCount,
      sumWarningCount));

    return sumErrCount;
  }

private:
  BlueprintParticleMesh m_queryMesh;
};

/// Utility function to initialize the logger
void initializeLogger()
{
  // Initialize Logger
  slic::initialize();
  slic::setLoggingMsgLevel(slic::message::Info);

  slic::LogStream* logStream;

#ifdef AXOM_USE_MPI
  std::string fmt = "[<RANK>][<LEVEL>]: <MESSAGE>\n";
  #ifdef AXOM_USE_LUMBERJACK
  const int RLIMIT = 8;
  logStream = new slic::LumberjackStream(&std::cout, MPI_COMM_WORLD, RLIMIT, fmt);
  #else
  logStream = new slic::SynchronizedStream(&std::cout, MPI_COMM_WORLD, fmt);
  #endif
#else
  std::string fmt = "[<LEVEL>]: <MESSAGE>\n";
  logStream = new slic::GenericOutputStream(&std::cout, fmt);
#endif  // AXOM_USE_MPI

  slic::addStreamToAllMsgLevels(logStream);
}

/// Utility function to finalize the logger
void finalizeLogger()
{
  if(slic::isInitialized())
  {
    slic::flushStreams();
    slic::finalize();
  }
}

//------------------------------------------------------------------------------
int main(int argc, char** argv)
{
  MPI_Init(&argc, &argv);
  int my_rank, num_ranks;
  MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);
  MPI_Comm_size(MPI_COMM_WORLD, &num_ranks);

  initializeLogger();
  //slic::setAbortOnWarning(true);

  //---------------------------------------------------------------------------
  // Set up and parse command line arguments
  //---------------------------------------------------------------------------
  Input params;
  axom::CLI::App app {"Driver for distributed distance query"};

  try
  {
    params.parse(argc, argv, app);
  }
  catch(const axom::CLI::ParseError& e)
  {
    int retval = -1;
    if(my_rank == 0)
    {
      retval = app.exit(e);
    }

    MPI_Bcast(&retval, 1, MPI_INT, 0, MPI_COMM_WORLD);
    MPI_Finalize();

    exit(retval);
  }

  // Issue warning about result-checking requiring good resolution.
  if(params.checkResults && params.randomSpacing)
  {
    SLIC_INFO(axom::fmt::format(
      "***Warning: Result-checking may yield false positive (warnings) when "
      "circle points have random spacing.  High resolution helps limit this."
      "We recommend at least 500 points for each radius length unit."));
  }

  constexpr int DIM = 2;

  using PointType = primal::Point<double, DIM>;
  using PointArray = axom::Array<PointType>;
  using IndexSet = slam::PositionSet<>;
  using Circle = primal::Sphere<double, DIM>;

  //---------------------------------------------------------------------------
  // Load/generate object mesh
  //---------------------------------------------------------------------------
  const Circle circle(
    PointType(params.circleCenter.data(), params.circleCenter.size()),
    params.circleRadius);

  sidre::DataStore objectDS;
  ObjectMeshWrapper object_mesh_wrapper(
    objectDS.getRoot()->createGroup("object_mesh", true));
  object_mesh_wrapper.setVerbosity(params.isVerbose());

  {
    const double prob = axom::utilities::random_real(0., 1.);
    int localDomainCount = params.minDomainCount
      + int(0.5 + prob*(params.maxDomainCount-params.minDomainCount));
    object_mesh_wrapper.generateCircleMesh(circle,
                                           params.circlePoints,
                                           localDomainCount,
                                           params.randomSpacing);
  }

  SLIC_INFO_IF(params.isVerbose(),
               axom::fmt::format("Object mesh has {} points",
                                 object_mesh_wrapper.getParticleMesh().numPoints()));

  object_mesh_wrapper.saveMesh(params.objectFile);
  slic::flushStreams();

  //---------------------------------------------------------------------------
  // Load computational mesh and generate a particle mesh over its nodes
  // These will be used to query the closest points on the object mesh(es)
  //---------------------------------------------------------------------------
  sidre::DataStore queryDS; // TODO: Need separate stores for object and query?
#if 1
  NewQueryMeshWrapper queryMeshWrapper(
    queryDS.getRoot()->createGroup("queryMesh", true),
    params.meshFile);
  // queryMeshWrapper.print_mesh_info();
  const int nMeshPoints = queryMeshWrapper.getParticleMesh().numPoints();
#else
  QueryMeshWrapper query_mesh_wrapper(params.distanceFile,
                                      params.getDCMeshName(),
                                      params.meshFile);
  query_mesh_wrapper.printMeshInfo();
  const int nMeshPoints = query_mesh_wrapper.getParticleMesh().numPoints();
#endif


  SLIC_INFO_IF(
    params.isVerbose(),
    axom::fmt::format("Query mesh has {} points on rank {}", nMeshPoints, my_rank));
  slic::flushStreams();

  //---------------------------------------------------------------------------
  // Initialize spatial index for querying points, and run query
  //---------------------------------------------------------------------------

  auto init_str =
    banner(axom::fmt::format("Initializing BVH tree over {} points",
                             params.circlePoints));

  auto query_str = banner(
    axom::fmt::format("Computing closest points for {} query points", nMeshPoints));

  axom::utilities::Timer initTimer(false);
  axom::utilities::Timer queryTimer(false);

  // Convert blueprint representation from sidre to conduit
  conduit::Node object_mesh_node;
  if(object_mesh_wrapper.getParticleMesh().numPoints() > 0)
  {
    object_mesh_wrapper.getBlueprintGroup()->createNativeLayout(object_mesh_node);
  }

  // Put sidre data into Conduit query_mesh_node.
  conduit::Node queryMeshNode;
  queryMeshWrapper.getBlueprintGroup()->createNativeLayout(queryMeshNode);
// std::cout << __WHERE << "queryMeshNode" << std::endl;
// queryMeshNode.print();

#if 0
  conduit::Node query_mesh_node;
  query_mesh_wrapper.getBlueprintGroup()->createNativeLayout(query_mesh_node);
std::cout << __WHERE << "query_mesh_node" << std::endl;
query_mesh_node.print();
#endif

  // Create distributed closest point query object and set some parameters
  quest::DistributedClosestPoint query;
  query.setRuntimePolicy(params.policy);
  query.setMpiCommunicator(MPI_COMM_WORLD, true);
  query.setDimension(DIM);
  query.setVerbosity(params.isVerbose());
  query.setDistanceThreshold(params.distThreshold);
  query.setObjectMesh(object_mesh_node, object_mesh_wrapper.getCoordsetName());

  // Build the spatial index over the object on each rank
  SLIC_INFO(init_str);
  slic::flushStreams();
  initTimer.start();
  query.generateBVHTree();
  initTimer.stop();

  // Run the distributed closest point query over the nodes of the computational mesh
  SLIC_INFO(query_str);
  slic::flushStreams();
  queryTimer.start();
#if 1
  query.computeClosestPoints(queryMeshNode,
                             queryMeshWrapper.getCoordsetName());
#else
  query.computeClosestPoints(query_mesh_node,
                             query_mesh_wrapper.getCoordsetName());
#endif
  queryTimer.stop();

  auto getMinMax =
    [](double inVal, double& minVal, double& maxVal, double& sumVal) {
      MPI_Allreduce(&inVal, &minVal, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
      MPI_Allreduce(&inVal, &maxVal, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
      MPI_Allreduce(&inVal, &sumVal, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
    };

  // Output some timing stats
  {
    double minInit, maxInit, sumInit;
    getMinMax(initTimer.elapsedTimeInSec(), minInit, maxInit, sumInit);

    double minQuery, maxQuery, sumQuery;
    getMinMax(queryTimer.elapsedTimeInSec(), minQuery, maxQuery, sumQuery);

    SLIC_INFO(axom::fmt::format(
      "Initialization with policy {} took {{avg:{}, min:{}, max:{}}} seconds",
      params.policy,
      sumInit / num_ranks,
      minInit,
      maxInit));
    SLIC_INFO(axom::fmt::format(
      "Query with policy {} took {{avg:{}, min:{}, max:{}}} seconds",
      params.policy,
      sumQuery / num_ranks,
      minQuery,
      maxQuery));
  }
  slic::flushStreams();

#if 1
  auto& queryMesh = queryMeshWrapper.getParticleMesh();
#else
  auto& queryMesh = query_mesh_wrapper.getParticleMesh();
#endif
  auto cpCoords =
    queryMesh.getNodalVectorField<PointType>(
      "cp_coords", 0);

  auto cpIndices =
    queryMesh.getNodalScalarField<axom::IndexType>(
      "cp_index", 0);

  if(params.isVerbose())
  {
    auto cpRank =
      queryMesh.getNodalScalarField<axom::IndexType>(
        "cp_rank", 0);

    SLIC_INFO(axom::fmt::format("Closest points ({}):", cpCoords.size()));
    for(auto i : IndexSet(cpCoords.size()))
    {
      SLIC_INFO(axom::fmt::format("\t{}: {{rank:{}, index:{}, position:{}}}",
                                  i,
                                  cpRank[i],
                                  cpIndices[i],
                                  cpCoords[i]));
    }
  }

  int errCount = 0;
  int localErrCount = 0;
  if(params.checkResults)
  {
#if 1
    localErrCount = queryMeshWrapper.checkClosestPoints<DIM>(circle, params);
#else
    localErrCount = query_mesh_wrapper.checkClosestPoints<DIM>(circle, params);
#endif
  }
  MPI_Allreduce(&localErrCount, &errCount, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);

  //---------------------------------------------------------------------------
  // Transform closest points to distances and directions
  //---------------------------------------------------------------------------
  using primal::squared_distance;

  // Output some stats about the per-rank query points
  {
    double minPts, maxPts, sumPts;
    getMinMax(nMeshPoints, minPts, maxPts, sumPts);
    SLIC_INFO(
      axom::fmt::format(" Query points: {{total:{}, min:{}, max:{}, avg:{}}}",
                        sumPts,
                        minPts,
                        maxPts,
                        sumPts / num_ranks));
    slic::flushStreams();
  }


  PointType nowhere(std::numeric_limits<double>::signaling_NaN());
  const double nodist = std::numeric_limits<double>::signaling_NaN();
#if 1
  queryMesh.registerNodalScalarField<double>("distance");
  queryMesh.registerNodalVectorField<double>("direction");
  for(axom::IndexType di = 0; di < queryMesh.domain_count(); ++di)
  {
    PointArray qPts = queryMeshWrapper.getVertexPositions<PointArray>(di);
    axom::ArrayView<double> distances = queryMesh.getNodalScalarField<double>("distance", di);
    axom::ArrayView<PointType> directions = queryMesh.getNodalVectorField<PointType>("direction", di);
    axom::IndexType ptCount = queryMeshWrapper.getParticleMesh().numPoints(di);
    for(auto ptIdx : IndexSet(ptCount))
    {
      const bool has_cp = cpIndices[ptIdx] >= 0;
      const PointType& cp = has_cp ? cpCoords[ptIdx] : nowhere;
      distances[ptIdx] = has_cp ? sqrt(squared_distance(qPts[ptIdx], cp)) : nodist;
      directions[ptIdx] = PointType(has_cp ? (cp - qPts[ptIdx]).array() : nowhere.array());
    }
// conduit::Node queryMeshNode1;
// queryMeshWrapper.getBlueprintGroup()->createNativeLayout(queryMeshNode1);
// std::cout << __FILE__<<':'<<__LINE__<< "queryMeshNode"<<std::endl; queryMeshNode.print();
// std::cout << __FILE__<<':'<<__LINE__<< "queryMeshNode1"<<std::endl; queryMeshNode1.print();
  }
#else
  auto* distances = query_mesh_wrapper.getDC()->GetField("distance");
  auto* directions = query_mesh_wrapper.getDC()->GetField("direction");
  auto qPts = query_mesh_wrapper.getVertexPositions<PointArray>();
  mfem::Array<int> dofs;
  for(auto idx : IndexSet(nMeshPoints))
  {
    const bool has_cp = cpIndices[idx] >= 0;
    const auto& cp = has_cp ? cpCoords[idx] : nowhere;

    (*distances)(idx) = has_cp ? sqrt(squared_distance(qPts[idx], cp)) : nodist;

    directions->FESpace()->GetVertexVDofs(idx, dofs);
    directions->SetSubVector(dofs,
                             has_cp ? (cp - qPts[idx]).data() : nowhere.data());
  }
#endif

  //---------------------------------------------------------------------------
  // Cleanup, save mesh/fields and exit
  //---------------------------------------------------------------------------
#if 1
  conduit::relay::mpi::io::blueprint::save_mesh(queryMeshNode,
                                                params.distanceFile,
                                                "hdf5",
                                                MPI_COMM_WORLD);
#else
  query_mesh_wrapper.saveMesh();
#endif

  if(errCount)
  {
    SLIC_INFO(axom::fmt::format(" Error exit: {} errors found.", errCount));
  }
  else
  {
    SLIC_INFO("Normal exit.");
  }

  finalizeLogger();
  MPI_Finalize();

  return errCount != 0;
}
